using System;
using System.Collections.Concurrent;
using System.Runtime.InteropServices;
using System.Security; // ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#pragma warning disable 1572
#pragma warning disable 1591

namespace SharpVk.Glfw
{
    /// <summary>
    ///     Interop functions for the GLFW3 API.
    /// </summary>
    public static unsafe class Glfw3
    {
        /// <summary>
        ///     The base name for the GLFW3 library.
        /// </summary>
        public const string GlfwDll = "glfw3";

        /// <summary>
        ///     Initializes the GLFW library.
        /// </summary>
        /// <returns>
        ///     True if successful, otherwise false.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwInit")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool Init();

        /// <summary>
        ///     This function destroys all remaining windows and cursors, restores
        ///     any modified gamma ramps and frees any other allocated resources.
        /// </summary>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwTerminate")]
        public static extern void Terminate();

        /// <summary>
        ///     This function retrieves the major, minor and revision numbers of
        ///     the GLFW library.
        /// </summary>
        /// <param name="major">
        ///     The major version number.
        /// </param>
        /// <param name="minor">
        ///     The minor version number.
        /// </param>
        /// <param name="rev">
        ///     The revision number.
        /// </param>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetVersion")]
        public static extern void GetVersion(out int major, out int minor, out int rev);

        /// <summary>
        ///     Returns the compile-time generated version string of the GLFW
        ///     library binary. It describes the version, platform, compiler and
        ///     any platform-specific compile-time options.
        /// </summary>
        /// <returns>
        ///     The compile-time generated version string of the GLFW library
        ///     binary.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetVersionString")]
        public static extern NativeString GetVersionString();

        /// <summary>
        ///     Creates a window and its associated OpenGL or OpenGL ES context.
        ///     Most of the options controlling how the window and its context
        ///     should be created are specified with window hints.
        /// </summary>
        /// <param name="width">
        ///     The desired width, in screen coordinates, of the window. This must
        ///     be greater than zero.
        /// </param>
        /// <param name="height">
        ///     The desired height, in screen coordinates, of the window. This must
        ///     be greater than zero.
        /// </param>
        /// <param name="title">
        ///     The initial window title.
        /// </param>
        /// <param name="monitor">
        ///     The monitor to use for full screen mode, or Null for windowed mode.
        /// </param>
        /// <param name="share">
        ///     The window whose context to share resources with, or Null to not share resources.
        /// </param>
        /// <returns>
        ///     The handle of the created window, or Null if an error occurred.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwCreateWindow")]
        public static extern WindowHandle CreateWindow(int width, int height, [MarshalAs(UnmanagedType.LPStr)] string title, MonitorHandle monitor, WindowHandle share);

        /// <summary>
        ///     Destroys the specified window and its context. On calling this
        ///     function, no further callbacks will be called for that window.
        /// </summary>
        /// <param name="window">
        ///     The window to destroy.
        /// </param>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwDestroyWindow")]
        public static extern void DestroyWindow(WindowHandle window);

        /// <summary>
        ///     Processes events in the event queue and then returns immediately.
        ///     Processing events will cause the window and input callbacks
        ///     associated with those events to be called.
        /// </summary>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwPollEvents")]
        public static extern void PollEvents();

        /// <summary>
        ///     Sets hints for the next call to CreateWindow. The hints, once set,
        ///     retain their values until changed by a call to WindowHint or
        ///     DefaultWindowHints, or until the library is terminated.
        /// </summary>
        /// <param name="hint">
        ///     The window hint to set.
        /// </param>
        /// <param name="value">
        ///     The new value of the window hint.
        /// </param>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwWindowHint")]
        public static extern void WindowHint(WindowAttribute hint, int value);

        /// <summary>
        ///     Returns the value of the close flag of the specified window.
        /// </summary>
        /// <param name="window">
        ///     The window to query.
        /// </param>
        /// <returns>
        ///     The value of the close flag.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwWindowShouldClose")]
        public static extern bool WindowShouldClose(WindowHandle window);

        /// <summary>
        ///     Creates a Vulkan surface for the specified window.
        /// </summary>
        /// <param name="instance">
        ///     The Vulkan instance to create the surface in.
        /// </param>
        /// <param name="window">
        ///     The window to create the surface for.
        /// </param>
        /// <param name="pAllocator">
        ///     The allocator to use, or NULL to use the default allocator.
        /// </param>
        /// <param name="surface">
        ///     Where to store the handle of the surface. This is set to
        ///     VK_NULL_HANDLE if an error occurred.
        /// </param>
        /// <returns>
        ///     Result.Success if successful, or a Vulkan error code if an error
        ///     occurred.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwCreateWindowSurface")]
        public static extern Result CreateWindowSurface(Interop.Instance instance, WindowHandle window, Interop.AllocationCallbacks* pAllocator, out ulong surface);

        /// <summary>
        ///     Returns an array of names of Vulkan instance extensions required by
        ///     GLFW for creating Vulkan surfaces for GLFW windows. If successful,
        ///     the list will always contains VK_KHR_surface, so if you don't
        ///     require any additional extensions you can pass this list directly
        ///     to the InstanceCreateInfo struct.
        /// </summary>
        /// <param name="count">
        ///     Where to store the number of extensions in the returned array. This
        ///     is set to zero if an error occurred.
        /// </param>
        /// <returns>
        ///     An array of extension names, or Null if an error occurred.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetRequiredInstanceExtensions")]
        public static extern byte** GetRequiredInstanceExtensions(out int count);

        /// <summary>
        ///     Sets the size callback of the specified window, which is called
        ///     when the window is resized. The callback is provided with the size,
        ///     in screen coordinates, of the client area of the window.
        /// </summary>
        /// <param name="window">
        ///     The window whose callback to set.
        /// </param>
        /// <param name="callback">
        ///     The new callback, or Null to remove the currently set callback.
        /// </param>
        /// <returns></returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwSetWindowSizeCallback")]
        public static extern WindowSizeDelegate SetWindowSizeCallback(WindowHandle window, WindowSizeDelegate callback);

        /// <summary>
        ///     Sets the error callback, which is called with an error code and a
        ///     human-readable description each time a GLFW error occurs.
        /// </summary>
        /// <param name="callback">
        ///     The new callback, or Null to remove the currently set callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or Null if no callback was set.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwSetErrorCallback")]
        public static extern ErrorDelegate SetErrorCallback(ErrorDelegate callback);

        /// <summary>
        ///     Returns an array of handles for all currently connected monitors.
        ///     The primary monitor is always first in the returned array. If no
        ///     monitors were found, this function returns Null.
        /// </summary>
        /// <param name="count">
        ///     Where to store the number of monitors in the returned array. This
        ///     is set to zero if an error occurred.
        /// </param>
        /// <returns>
        ///     An array of monitor handles, or Null if no monitors were found or
        ///     if an error occurred.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetMonitors")]
        public static extern MonitorHandle* GetMonitors(out int count);

        /// <summary>
        ///     Returns the primary monitor. This is usually the monitor where
        ///     elements like the task bar or global menu bar are located.
        /// </summary>
        /// <returns>
        ///     The primary monitor, or Null if no monitors were found or if an
        ///     error occurred.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetPrimaryMonitor")]
        public static extern MonitorHandle GetPrimaryMonitor();

        /// <summary>
        ///     Returns the position, in screen coordinates, of the upper-left
        ///     corner of the specified monitor.
        /// </summary>
        /// <param name="monitor">
        ///     The monitor to query.
        /// </param>
        /// <param name="xPos">
        ///     Returns the monitor x-coordinate.
        /// </param>
        /// <param name="yPos">
        ///     Returns the monitor y-coordinate.
        /// </param>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetMonitorPos")]
        public static extern void GetMonitorPos(MonitorHandle monitor, out int xPos, out int yPos);

        /// <summary>
        ///     Returns the size, in millimetres, of the display area of the
        ///     specified monitor.
        /// </summary>
        /// <param name="monitor">
        ///     The monitor to query.
        /// </param>
        /// <param name="widthMm">
        ///     The width, in millimetres, of the monitor's display area.
        /// </param>
        /// <param name="heightMm">
        ///     The width, in millimetres, of the monitor's display area.
        /// </param>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetMonitorPhysicalSize")]
        public static extern void GetMonitorPhysicalSize(MonitorHandle monitor, out int widthMm, out int heightMm);

        /// <summary>
        ///     Returns a human-readable name, of the specified monitor. The name
        ///     typically reflects the make and model of the monitor and is not
        ///     guaranteed to be unique among the connected monitors.
        /// </summary>
        /// <param name="monitor">
        ///     The monitor to query.
        /// </param>
        /// <returns>
        ///     The name of the monitor, or Null if an error occurred.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetMonitorName")]
        public static extern NativeString GetMonitorName(MonitorHandle monitor);

        /// <summary>
        ///     Sets the monitor configuration callback, or removes the currently
        ///     set callback. This is called when a monitor is connected to or
        ///     disconnected from the system.
        /// </summary>
        /// <param name="callback">
        ///     The new callback, or Null to remove the currently set callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or NULL if no callback was set or the
        ///     library had not been initialized.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwSetMonitorCallback")]
        public static extern MonitorEventDelegate SetMonitorCallback(MonitorEventDelegate callback);

        /// <summary>
        ///     Returns an array of all video modes supported by the specified
        ///     monitor. The returned array is sorted in ascending order, first by
        ///     color bit depth (the sum of all channel depths) and then by
        ///     resolution area (the product of width and height).
        /// </summary>
        /// <param name="monitor">
        ///     The monitor to query.
        /// </param>
        /// <param name="count">
        ///     Tthe number of video modes in the returned array. This is set to
        ///     zero if an error occurred.
        /// </param>
        /// <returns>
        ///     An array of video modes, or Null if an error occurred.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetVideoModes")]
        public static extern VideoMode* GetVideoModes(MonitorHandle monitor, out int count);

        /// <summary>
        ///     Returns the current video mode of the specified monitor. If you
        ///     have created a full screen window for that monitor, the return
        ///     value will depend on whether that window is iconified.
        /// </summary>
        /// <param name="monitor">
        ///     The monitor to query.
        /// </param>
        /// <returns>
        ///     A wrapped pointer to the current mode of the monitor, or Null if
        ///     an error occurred.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetVideoMode")]
        public static extern VideoModePointer GetVideoMode(MonitorHandle monitor);

        /// <summary>
        ///     Generates a 256-element gamma ramp from the specified exponent and
        ///     then calls glfwSetGammaRamp with it. The value must be a finite
        ///     number greater than zero.
        /// </summary>
        /// <param name="monitor">
        ///     The monitor whose gamma ramp to set.
        /// </param>
        /// <param name="gamma">
        ///     The desired exponent.
        /// </param>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwSetGamma")]
        public static extern void SetGamma(MonitorHandle monitor, float gamma);

        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetInputMode")]
        public static extern int GetInputMode(WindowHandle window, int mode);

        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwSetInputMode")]
        public static extern void SetInputMode(WindowHandle window, int mode, int value);

        /// <summary>
        ///     Returns the localized name of the specified printable key. This is
        ///     intended for displaying key bindings to the user.
        /// </summary>
        /// <param name="key">
        ///     The key to query, or Key.Unknown.
        /// </param>
        /// <param name="scancode">
        ///     The scancode of the key to query, if key is Key.Unknown.
        /// </param>
        /// <returns>
        ///     The localized name of the key, or Null.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetKeyName")]
        public static extern NativeString GetKeyName(Key key, int scancode);

        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetKey")]
        public static extern InputAction GetKey(WindowHandle window, Key key);

        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetMouseButton")]
        public static extern InputAction GetMouseButton(WindowHandle window, MouseButton button);

        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwGetCursorPos")]
        public static extern void GetCursorPosition(WindowHandle window, out double xPosition, out double yPosition);

        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwSetCursorPos")]
        public static extern void SetCursorPosition(WindowHandle window, double xPosition, double yPosition);

        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwSetKeyCallback")]
        public static extern KeyDelegate SetKeyCallback(WindowHandle window, KeyDelegate callback);

        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwSetCharCallback")]
        public static extern KeyDelegate SetCharCallback(WindowHandle window, CharDelegate callback);

        /// <summary>
        ///     <para>
        ///         Sets a callback for Mouse movement events. Use this for full
        ///         mouse path resolution between PollEvents() calls.
        ///     </para>
        ///     <para>
        ///         From GLFW Documentation: The callback functions receives the
        ///         cursor position, measured in screen coordinates but relative to the
        ///         top-left corner of the window client area. On platforms that
        ///         provide it, the full sub-pixel cursor position is passed on.
        ///     </para>
        /// </summary>
        /// <returns>
        ///     The previously set callback, or NULL if no callback was set or the
        ///     library had not been initialized.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwSetCursorPosCallback")]
        public static extern CursorPosDelegate SetCursorPosCallback(WindowHandle window, CursorPosDelegate callback);

        /// <summary>
        ///     <para>
        ///         Sets a Callback for Button Events (i.e. clicks). This also
        ///         detects mouse press and release events done between PollEvents()
        ///         calls.
        ///     </para>
        ///     <para>
        ///         From GLFW Documentation: Whenever you poll state, you risk
        ///         missing the state change you are looking for. If a pressed mouse
        ///         button is released again before you poll its state, you will have
        ///         missed the button press. The recommended solution for this is to
        ///         use a mouse button callback, but there is also the
        ///         GLFW_STICKY_MOUSE_BUTTONS input mode.
        ///     </para>
        /// </summary>
        /// <returns>
        ///     The previously set callback, or NULL if no callback was set or the
        ///     library had not been initialized.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwSetMouseButtonCallback")]
        public static extern MouseButtonDelegate SetMouseButtonPosCallback(WindowHandle window, MouseButtonDelegate callback);

        /// <summary>
        ///     Sets a Callback for Mouse Scrolling Events. (i.e. scroll wheel)
        ///     There is no polling support for this, so if youre interested in the wheel, you have to set this callback
        ///     NOTE: your normal desktop mouse variant likely only reports Y-Coordinate
        /// </summary>
        /// <returns>
        ///     The previously set callback, or NULL if no callback was set or the
        ///     library had not been initialized.
        /// </returns>
        [DllImport(GlfwDll, CallingConvention = CallingConvention.Cdecl, EntryPoint = "glfwSetScrollCallback")]
        public static extern ScrollDelegate SetScrollCallback(WindowHandle window, ScrollDelegate callback);

        /// <summary>
        ///     Returns an array of names of Vulkan instance extensions required by
        ///     GLFW for creating Vulkan surfaces for GLFW windows. If successful,
        ///     the list will always contains VK_KHR_surface, so if you don't
        ///     require any additional extensions you can pass this list directly
        ///     to the InstanceCreateInfo struct.
        /// </summary>
        /// <returns>
        ///     An array of extension names, or Null if an error occurred.
        /// </returns>
        public static string[] GetRequiredInstanceExtensions()
        {
            var namePointer = GetRequiredInstanceExtensions(out var count);

            var result = new string[count];

            for (var nameIndex = 0; nameIndex < count; nameIndex++) result[nameIndex] = Marshal.PtrToStringAnsi(new IntPtr(namePointer[nameIndex]));

            return result;
        }

        /// <summary>
        ///     Returns an array of handles for all currently connected monitors.
        ///     The primary monitor is always first in the returned array. If no
        ///     monitors were found, this function returns Null.
        /// </summary>
        /// <returns>
        ///     An array of monitor handles, or Null if no monitors were found or
        ///     if an error occurred.
        /// </returns>
        public static MonitorHandle[] GetMonitors()
        {
            var monitorPointer = GetMonitors(out var count);

            var result = new MonitorHandle[count];

            for (var i = 0; i < count; i++) result[i] = monitorPointer[i];

            return result;
        }

        /// <summary>
        ///     Returns an array of all video modes supported by the specified
        ///     monitor. The returned array is sorted in ascending order, first by
        ///     color bit depth (the sum of all channel depths) and then by
        ///     resolution area (the product of width and height).
        /// </summary>
        /// <param name="monitor">
        ///     The monitor to query.
        /// </param>
        /// <returns>
        ///     An array of video modes, or Null if an error occurred.
        /// </returns>
        public static VideoMode[] GetVideoModes(MonitorHandle monitor)
        {
            var videoModePointer = GetVideoModes(monitor, out var count);

            var result = new VideoMode[count];

            for (var i = 0; i < count; i++) result[i] = videoModePointer[i];

            return result;
        }

        /// <summary>
        ///     This function retrieves the version number of the GLFW library.
        /// </summary>
        /// <returns>
        ///     The version number of the GLFW library.
        /// </returns>
        public static Version GetVersion()
        {
            GetVersion(out var major, out var minor, out var revision);

            return new Version(major, minor, revision);
        }
    }
}

namespace glfw3
{
    public enum VkResult
    {
        VkSuccess = 0,
        VkNotReady = 1,
        VkTimeout = 2,
        VkEventSet = 3,
        VkEventReset = 4,
        VkIncomplete = 5,
        VkErrorOutOfHostMemory = -1,
        VkErrorOutOfDeviceMemory = -2,
        VkErrorInitializationFailed = -3,
        VkErrorDeviceLost = -4,
        VkErrorMemoryMapFailed = -5,
        VkErrorLayerNotPresent = -6,
        VkErrorExtensionNotPresent = -7,
        VkErrorFeatureNotPresent = -8,
        VkErrorIncompatibleDriver = -9,
        VkErrorTooManyObjects = -10,
        VkErrorFormatNotSupported = -11,
        VkErrorFragmentedPool = -12,
        VkErrorSurfaceLostKhr = -1000000000,
        VkErrorNativeWindowInUseKhr = -1000000001,
        VkSuboptimalKhr = 1000001003,
        VkErrorOutOfDateKhr = -1000001004,
        VkErrorIncompatibleDisplayKhr = -1000003001,
        VkErrorValidationFailedExt = -1000011001,
        VkErrorInvalidShaderNv = -1000012000,
        VkErrorOutOfPoolMemoryKhr = -1000069000,
        VkResultBeginRange = -12,
        VkResultEndRange = 5,
        VkResultRangeSize = 18,
        VkResultMaxEnum = 2147483647
    }

    public enum Key
    {
        Unknown = -1,
        Space = 32,
        Apostrophe = 39,
        Comma = 44,
        Minus = 45,
        Period = 46,
        Slash = 47,
        _0 = 48,
        _1 = 49,
        _2 = 50,
        _3 = 51,
        _4 = 52,
        _5 = 53,
        _6 = 54,
        _7 = 55,
        _8 = 56,
        _9 = 57,
        Semicolon = 59,
        Equal = 61,
        A = 65,
        B = 66,
        C = 67,
        D = 68,
        E = 69,
        F = 70,
        G = 71,
        H = 72,
        I = 73,
        J = 74,
        K = 75,
        L = 76,
        M = 77,
        N = 78,
        O = 79,
        P = 80,
        Q = 81,
        R = 82,
        S = 83,
        T = 84,
        U = 85,
        V = 86,
        W = 87,
        X = 88,
        Y = 89,
        Z = 90,
        LeftBracket = 91,
        Backslash = 92,
        RightBracket = 93,
        GraveAccent = 96,
        World1 = 161,
        World2 = 162,
        Escape = 256,
        Enter = 257,
        Tab = 258,
        Backspace = 259,
        Insert = 260,
        Delete = 261,
        Right = 262,
        Left = 263,
        Down = 264,
        Up = 265,
        PageUp = 266,
        PageDown = 267,
        Home = 268,
        End = 269,
        CapsLock = 280,
        ScrollLock = 281,
        NumLock = 282,
        PrintScreen = 283,
        Pause = 284,
        F1 = 290,
        F2 = 291,
        F3 = 292,
        F4 = 293,
        F5 = 294,
        F6 = 295,
        F7 = 296,
        F8 = 297,
        F9 = 298,
        F10 = 299,
        F11 = 300,
        F12 = 301,
        F13 = 302,
        F14 = 303,
        F15 = 304,
        F16 = 305,
        F17 = 306,
        F18 = 307,
        F19 = 308,
        F20 = 309,
        F21 = 310,
        F22 = 311,
        F23 = 312,
        F24 = 313,
        F25 = 314,
        Kp0 = 320,
        Kp1 = 321,
        Kp2 = 322,
        Kp3 = 323,
        Kp4 = 324,
        Kp5 = 325,
        Kp6 = 326,
        Kp7 = 327,
        Kp8 = 328,
        Kp9 = 329,
        KpDecimal = 330,
        KpDivide = 331,
        KpMultiply = 332,
        KpSubtract = 333,
        KpAdd = 334,
        KpEnter = 335,
        KpEqual = 336,
        LeftShift = 340,
        LeftControl = 341,
        LeftAlt = 342,
        LeftSuper = 343,
        RightShift = 344,
        RightControl = 345,
        RightAlt = 346,
        RightSuper = 347,
        Menu = 348,
        Last = 348
    }

    public enum Mouse
    {
        _1 = 0,
        _2 = 1,
        _3 = 2,
        _4 = 3,
        _5 = 4,
        _6 = 5,
        _7 = 6,
        _8 = 7,
        Last = 7,
        Left = 0,
        Right = 1,
        Middle = 2
    }

    public enum Joystick
    {
        _1 = 0,
        _2 = 1,
        _3 = 2,
        _4 = 3,
        _5 = 4,
        _6 = 5,
        _7 = 6,
        _8 = 7,
        _9 = 8,
        _10 = 9,
        _11 = 10,
        _12 = 11,
        _13 = 12,
        _14 = 13,
        _15 = 14,
        _16 = 15,
        Last = 15
    }

    public enum KeyModifier
    {
        ModShift = 1,
        ModControl = 2,
        ModAlt = 4,
        ModSuper = 8
    }

    public enum Error
    {
        NotInitialized = 65537,
        NoCurrentContext = 65538,
        InvalidEnum = 65539,
        InvalidValue = 65540,
        OutOfMemory = 65541,
        ApiUnavailable = 65542,
        VersionUnavailable = 65543,
        PlatformError = 65544,
        FormatUnavailable = 65545,
        NoWindowContext = 65546
    }

    public enum State
    {
        True = 1,
        False = 0,
        Release = 0,
        Press = 1,
        Repeat = 2,
        Focused = 131073,
        Iconified = 131074,
        Resizable = 131075,
        Visible = 131076,
        Decorated = 131077,
        AutoIconify = 131078,
        Floating = 131079,
        Maximized = 131080,
        RedBits = 135169,
        GreenBits = 135170,
        BlueBits = 135171,
        AlphaBits = 135172,
        DepthBits = 135173,
        StencilBits = 135174,
        AccumRedBits = 135175,
        AccumGreenBits = 135176,
        AccumBlueBits = 135177,
        AccumAlphaBits = 135178,
        AuxBuffers = 135179,
        Stereo = 135180,
        Samples = 135181,
        SrgbCapable = 135182,
        RefreshRate = 135183,
        Doublebuffer = 135184,
        ClientApi = 139265,
        ContextVersionMajor = 139266,
        ContextVersionMinor = 139267,
        ContextRevision = 139268,
        ContextRobustness = 139269,
        OpenglForwardCompat = 139270,
        OpenglDebugContext = 139271,
        OpenglProfile = 139272,
        ContextReleaseBehavior = 139273,
        ContextNoError = 139274,
        ContextCreationApi = 139275,
        NoApi = 0,
        OpenglApi = 196609,
        OpenglEsApi = 196610,
        NoRobustness = 0,
        NoResetNotification = 200705,
        LoseContextOnReset = 200706,
        OpenglAnyProfile = 0,
        OpenglCoreProfile = 204801,
        OpenglCompatProfile = 204802,
        Cursor = 208897,
        StickyKeys = 208898,
        StickyMouseButtons = 208899,
        CursorNormal = 212993,
        CursorHidden = 212994,
        CursorDisabled = 212995,
        AnyReleaseBehavior = 0,
        ReleaseBehaviorFlush = 217089,
        ReleaseBehaviorNone = 217090,
        NativeContextApi = 221185,
        EglContextApi = 221186,
        Connected = 262145,
        Disconnected = 262146,
        DontCare = -1
    }

    public enum Version
    {
        VersionMajor = 3,
        VersionMinor = 2,
        VersionRevision = 1
    }

    /// <summary>
    ///     Generic function pointer used for returning client API function pointers
    ///     without forcing a cast from a regular pointer.
    /// </summary>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWglproc();

    /// <summary>
    ///     Generic function pointer used for returning Vulkan API function pointers
    ///     without forcing a cast from a regular pointer.
    /// </summary>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWvkproc();

    /// <summary>  Opaque monitor object.</summary>
    /// <summary>  Opaque window object.</summary>
    /// <summary>  Opaque cursor object.</summary>
    /// <summary>  This is the function signature for error callback functions.</summary>
    /// <param name="error">An [error code](</param>
    /// <param name="description">A UTF-8 encoded string describing the error.</param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWerrorfun(int _0, [MarshalAs(UnmanagedType.LPStr)] string _1);

    /// <summary>  This is the function signature for window position callback functions.</summary>
    /// <param name="window">The window that was moved.</param>
    /// <param name="xpos">
    ///     The new x-coordinate, in screen coordinates, of the
    ///     upper-left corner of the client area of the window.
    /// </param>
    /// <param name="ypos">
    ///     The new y-coordinate, in screen coordinates, of the
    ///     upper-left corner of the client area of the window.
    /// </param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWwindowposfun(IntPtr _0, int _1, int _2);

    /// <summary>  This is the function signature for window size callback functions.</summary>
    /// <param name="window">The window that was resized.</param>
    /// <param name="width">The new width, in screen coordinates, of the window.</param>
    /// <param name="height">The new height, in screen coordinates, of the window.</param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWwindowsizefun(IntPtr _0, int _1, int _2);

    /// <summary>  This is the function signature for window close callback functions.</summary>
    /// <param name="window">The window that the user attempted to close.</param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWwindowclosefun(IntPtr _0);

    /// <summary>  This is the function signature for window refresh callback functions.</summary>
    /// <param name="window">The window whose content needs to be refreshed.</param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWwindowrefreshfun(IntPtr _0);

    /// <summary>  This is the function signature for window focus callback functions.</summary>
    /// <param name="window">The window that gained or lost input focus.</param>
    /// <param name="focused">
    ///     `GLFW_TRUE` if the window was given input focus, or
    ///     `GLFW_FALSE` if it lost it.
    /// </param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWwindowfocusfun(IntPtr _0, int _1);

    /// <summary>
    ///     This is the function signature for window iconify/restore callback
    ///     functions.
    /// </summary>
    /// <param name="window">The window that was iconified or restored.</param>
    /// <param name="iconified">
    ///     `GLFW_TRUE` if the window was iconified, or
    ///     `GLFW_FALSE` if it was restored.
    /// </param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWwindowiconifyfun(IntPtr _0, int _1);

    /// <summary>
    ///     This is the function signature for framebuffer resize callback
    ///     functions.
    /// </summary>
    /// <param name="window">The window whose framebuffer was resized.</param>
    /// <param name="width">The new width, in pixels, of the framebuffer.</param>
    /// <param name="height">The new height, in pixels, of the framebuffer.</param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWframebuffersizefun(IntPtr _0, int _1, int _2);

    /// <summary>  This is the function signature for mouse button callback functions.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="button">
    ///     The [mouse button](
    ///     released.
    /// </param>
    /// <param name="action">One of `GLFW_PRESS` or `GLFW_RELEASE`.</param>
    /// <param name="mods">
    ///     Bit field describing which [modifier keys](
    ///     held down.
    /// </param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWmousebuttonfun(IntPtr _0, int _1, int _2, int _3);

    /// <summary>  This is the function signature for cursor position callback functions.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="xpos">
    ///     The new cursor x-coordinate, relative to the left edge of
    ///     the client area.
    /// </param>
    /// <param name="ypos">
    ///     The new cursor y-coordinate, relative to the top edge of the
    ///     client area.
    /// </param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWcursorposfun(IntPtr _0, double _1, double _2);

    /// <summary>  This is the function signature for cursor enter/leave callback functions.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="entered">
    ///     `GLFW_TRUE` if the cursor entered the window's client
    ///     area, or `GLFW_FALSE` if it left it.
    /// </param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWcursorenterfun(IntPtr _0, int _1);

    /// <summary>  This is the function signature for scroll callback functions.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="xoffset">The scroll offset along the x-axis.</param>
    /// <param name="yoffset">The scroll offset along the y-axis.</param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWscrollfun(IntPtr _0, double _1, double _2);

    /// <summary>  This is the function signature for keyboard key callback functions.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="key">The [keyboard key](</param>
    /// <param name="scancode">The system-specific scancode of the key.</param>
    /// <param name="action">`GLFW_PRESS`, `GLFW_RELEASE` or `GLFW_REPEAT`.</param>
    /// <param name="mods">
    ///     Bit field describing which [modifier keys](
    ///     held down.
    /// </param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWkeyfun(IntPtr _0, int _1, int _2, int _3, int _4);

    /// <summary>  This is the function signature for Unicode character callback functions.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="codepoint">The Unicode code point of the character.</param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWcharfun(IntPtr _0, uint _1);

    /// <summary>
    ///     This is the function signature for Unicode character with modifiers callback
    ///     functions.  It is called for each input character, regardless of what
    ///     modifier keys are held down.
    /// </summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="codepoint">The Unicode code point of the character.</param>
    /// <param name="mods">
    ///     Bit field describing which [modifier keys](
    ///     held down.
    /// </param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWcharmodsfun(IntPtr _0, uint _1, int _2);

    /// <summary>  This is the function signature for file drop callbacks.</summary>
    /// <param name="window">The window that received the event.</param>
    /// <param name="count">The number of dropped files.</param>
    /// <param name="paths">The UTF-8 encoded file and/or directory path names.</param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public unsafe delegate void GlfWdropfun(IntPtr _0, int _1, sbyte** _2);

    /// <summary>  This is the function signature for monitor configuration callback functions.</summary>
    /// <param name="monitor">The monitor that was connected or disconnected.</param>
    /// <param name="event">One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.</param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWmonitorfun(IntPtr _0, int _1);

    /// <summary>
    ///     This is the function signature for joystick configuration callback
    ///     functions.
    /// </summary>
    /// <param name="joy">The joystick that was connected or disconnected.</param>
    /// <param name="event">One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.</param>
    [SuppressUnmanagedCodeSecurity]
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void GlfWjoystickfun(int _0, int _1);

    public unsafe class GlfWmonitor
    {
        public static readonly ConcurrentDictionary<IntPtr, GlfWmonitor> NativeToManagedMap = new ConcurrentDictionary<IntPtr, GlfWmonitor>();
        protected void*[] OriginalVTables;

        protected bool OwnsNativeInstance;

        protected int PointerAdjustment;

        private GlfWmonitor(Public native)
            : this(__CopyValue(native))
        {
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected GlfWmonitor(void* native)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public IntPtr Instance { get; protected set; }

        public static GlfWmonitor __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new GlfWmonitor(native.ToPointer());
        }

        public static GlfWmonitor __CreateInstance(Public native, bool skipVTables = false)
        {
            return new GlfWmonitor(native);
        }

        private static void* __CopyValue(Public native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Public));
            *(Public*)ret = native;
            return ret.ToPointer();
        }

        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public struct Public
        {
        }
    }

    public class GlfWwindow
    {
        public GlfWwindow(IntPtr ptr)
        {
            Instance = ptr;
        }

        public IntPtr Instance { get; protected set; }

        public static GlfWwindow __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new GlfWwindow(native);
        }
    }

    public unsafe class GlfWcursor
    {
        public static readonly ConcurrentDictionary<IntPtr, GlfWcursor> NativeToManagedMap = new ConcurrentDictionary<IntPtr, GlfWcursor>();
        protected void*[] OriginalVTables;

        protected bool OwnsNativeInstance;

        protected int PointerAdjustment;

        private GlfWcursor(Public native)
            : this(__CopyValue(native))
        {
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected GlfWcursor(void* native)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public IntPtr Instance { get; protected set; }

        public static GlfWcursor __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new GlfWcursor(native.ToPointer());
        }

        public static GlfWcursor __CreateInstance(Public native, bool skipVTables = false)
        {
            return new GlfWcursor(native);
        }

        private static void* __CopyValue(Public native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Public));
            *(Public*)ret = native;
            return ret.ToPointer();
        }

        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public struct Public
        {
        }
    }

    /// <summary>  This describes a single video mode.</summary>
    public unsafe class GlfWvidmode : IDisposable
    {
        public static readonly ConcurrentDictionary<IntPtr, GlfWvidmode> NativeToManagedMap = new ConcurrentDictionary<IntPtr, GlfWvidmode>();
        protected void*[] OriginalVTables;

        protected bool OwnsNativeInstance;

        protected int PointerAdjustment;

        private GlfWvidmode(Public native)
            : this(__CopyValue(native))
        {
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected GlfWvidmode(void* native)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public GlfWvidmode()
        {
            Instance = Marshal.AllocHGlobal(sizeof(Public));
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public GlfWvidmode(GlfWvidmode _0)
        {
            Instance = Marshal.AllocHGlobal(sizeof(Public));
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *(Public*)Instance = *(Public*)_0.Instance;
        }

        public IntPtr Instance { get; protected set; }

        public int Width
        {
            get => ((Public*)Instance)->width;

            set => ((Public*)Instance)->width = value;
        }

        public int Height
        {
            get => ((Public*)Instance)->height;

            set => ((Public*)Instance)->height = value;
        }

        public int RedBits
        {
            get => ((Public*)Instance)->redBits;

            set => ((Public*)Instance)->redBits = value;
        }

        public int GreenBits
        {
            get => ((Public*)Instance)->greenBits;

            set => ((Public*)Instance)->greenBits = value;
        }

        public int BlueBits
        {
            get => ((Public*)Instance)->blueBits;

            set => ((Public*)Instance)->blueBits = value;
        }

        public int RefreshRate
        {
            get => ((Public*)Instance)->refreshRate;

            set => ((Public*)Instance)->refreshRate = value;
        }

        public void Dispose()
        {
            Dispose(true);
        }

        public static GlfWvidmode __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new GlfWvidmode(native.ToPointer());
        }

        public static GlfWvidmode __CreateInstance(Public native, bool skipVTables = false)
        {
            return new GlfWvidmode(native);
        }

        private static void* __CopyValue(Public native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Public));
            *(Public*)ret = native;
            return ret.ToPointer();
        }

        public virtual void Dispose(bool disposing)
        {
            if (Instance == IntPtr.Zero)
                return;
            GlfWvidmode dummy;
            NativeToManagedMap.TryRemove(Instance, out dummy);
            if (OwnsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public struct Public
        {
            [FieldOffset(0)] public int width;

            [FieldOffset(4)] public int height;

            [FieldOffset(8)] public int redBits;

            [FieldOffset(12)] public int greenBits;

            [FieldOffset(16)] public int blueBits;

            [FieldOffset(20)] public int refreshRate;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.ThisCall,
                EntryPoint = "??0GLFWvidmode@@QAE@ABU0@@Z")]
            public static extern IntPtr cctor_1(IntPtr instance, IntPtr _0);
        }
    }

    /// <summary>  This describes the gamma ramp for a monitor.</summary>
    public unsafe class GlfWgammaramp : IDisposable
    {
        public static readonly ConcurrentDictionary<IntPtr, GlfWgammaramp> NativeToManagedMap = new ConcurrentDictionary<IntPtr, GlfWgammaramp>();
        protected void*[] OriginalVTables;

        protected bool OwnsNativeInstance;

        protected int PointerAdjustment;

        private GlfWgammaramp(Public native)
            : this(__CopyValue(native))
        {
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected GlfWgammaramp(void* native)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public GlfWgammaramp()
        {
            Instance = Marshal.AllocHGlobal(sizeof(Public));
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public GlfWgammaramp(GlfWgammaramp _0)
        {
            Instance = Marshal.AllocHGlobal(sizeof(Public));
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *(Public*)Instance = *(Public*)_0.Instance;
        }

        public IntPtr Instance { get; protected set; }

        public ushort* Red
        {
            get => (ushort*)((Public*)Instance)->red;

            set => ((Public*)Instance)->red = (IntPtr)value;
        }

        public ushort* Green
        {
            get => (ushort*)((Public*)Instance)->green;

            set => ((Public*)Instance)->green = (IntPtr)value;
        }

        public ushort* Blue
        {
            get => (ushort*)((Public*)Instance)->blue;

            set => ((Public*)Instance)->blue = (IntPtr)value;
        }

        public uint Size
        {
            get => ((Public*)Instance)->size;

            set => ((Public*)Instance)->size = value;
        }

        public void Dispose()
        {
            Dispose(true);
        }

        public static GlfWgammaramp __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new GlfWgammaramp(native.ToPointer());
        }

        public static GlfWgammaramp __CreateInstance(Public native, bool skipVTables = false)
        {
            return new GlfWgammaramp(native);
        }

        private static void* __CopyValue(Public native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Public));
            *(Public*)ret = native;
            return ret.ToPointer();
        }

        public virtual void Dispose(bool disposing)
        {
            if (Instance == IntPtr.Zero)
                return;
            GlfWgammaramp dummy;
            NativeToManagedMap.TryRemove(Instance, out dummy);
            if (OwnsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public struct Public
        {
            [FieldOffset(0)] public IntPtr red;

            [FieldOffset(4)] public IntPtr green;

            [FieldOffset(8)] public IntPtr blue;

            [FieldOffset(12)] public uint size;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.ThisCall,
                EntryPoint = "??0GLFWgammaramp@@QAE@ABU0@@Z")]
            public static extern IntPtr cctor_1(IntPtr instance, IntPtr _0);
        }
    }

    public unsafe class GlfWimage : IDisposable
    {
        public static readonly ConcurrentDictionary<IntPtr, GlfWimage> NativeToManagedMap = new ConcurrentDictionary<IntPtr, GlfWimage>();
        protected void*[] OriginalVTables;

        protected bool OwnsNativeInstance;

        protected int PointerAdjustment;

        private GlfWimage(Public native)
            : this(__CopyValue(native))
        {
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected GlfWimage(void* native)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public GlfWimage()
        {
            Instance = Marshal.AllocHGlobal(sizeof(Public));
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public GlfWimage(GlfWimage _0)
        {
            Instance = Marshal.AllocHGlobal(sizeof(Public));
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *(Public*)Instance = *(Public*)_0.Instance;
        }

        public IntPtr Instance { get; protected set; }

        public int Width
        {
            get => ((Public*)Instance)->width;

            set => ((Public*)Instance)->width = value;
        }

        public int Height
        {
            get => ((Public*)Instance)->height;

            set => ((Public*)Instance)->height = value;
        }

        public byte* Pixels
        {
            get => (byte*)((Public*)Instance)->pixels;

            set => ((Public*)Instance)->pixels = (IntPtr)value;
        }

        public void Dispose()
        {
            Dispose(true);
        }

        public static GlfWimage __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new GlfWimage(native.ToPointer());
        }

        public static GlfWimage __CreateInstance(Public native, bool skipVTables = false)
        {
            return new GlfWimage(native);
        }

        private static void* __CopyValue(Public native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Public));
            *(Public*)ret = native;
            return ret.ToPointer();
        }

        public virtual void Dispose(bool disposing)
        {
            if (Instance == IntPtr.Zero)
                return;
            GlfWimage dummy;
            NativeToManagedMap.TryRemove(Instance, out dummy);
            if (OwnsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public struct Public
        {
            [FieldOffset(0)] public int width;

            [FieldOffset(4)] public int height;

            [FieldOffset(8)] public IntPtr pixels;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.ThisCall,
                EntryPoint = "??0GLFWimage@@QAE@ABU0@@Z")]
            public static extern IntPtr cctor_1(IntPtr instance, IntPtr _0);
        }
    }

    public unsafe class Test : IDisposable
    {
        public static readonly ConcurrentDictionary<IntPtr, Test> NativeToManagedMap = new ConcurrentDictionary<IntPtr, Test>();
        protected void*[] OriginalVTables;

        protected bool OwnsNativeInstance;

        protected int PointerAdjustment;

        private Test(Public native)
            : this(__CopyValue(native))
        {
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected Test(void* native)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public Test()
        {
            Instance = Marshal.AllocHGlobal(sizeof(Public));
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public Test(Test _0)
        {
            Instance = Marshal.AllocHGlobal(sizeof(Public));
            OwnsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *(Public*)Instance = *(Public*)_0.Instance;
        }

        public IntPtr Instance { get; protected set; }

        public void Dispose()
        {
            Dispose(true);
        }

        public static Test __CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new Test(native.ToPointer());
        }

        public static Test __CreateInstance(Public native, bool skipVTables = false)
        {
            return new Test(native);
        }

        private static void* __CopyValue(Public native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Public));
            *(Public*)ret = native;
            return ret.ToPointer();
        }

        public virtual void Dispose(bool disposing)
        {
            if (Instance == IntPtr.Zero)
                return;
            Test dummy;
            NativeToManagedMap.TryRemove(Instance, out dummy);
            if (OwnsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public struct Public
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.ThisCall,
                EntryPoint = "??0Test@@QAE@ABU0@@Z")]
            public static extern IntPtr cctor_1(IntPtr instance, IntPtr _0);
        }
    }

    public unsafe class Glfw3
    {
        /// <summary>
        ///     This function initializes the GLFW library.  Before most GLFW functions can
        ///     be used, GLFW must be initialized, and before an application terminates GLFW
        ///     should be terminated in order to free any resources allocated during or
        ///     after initialization.
        ///     If this function fails, it calls
        ///     succeeds, you should call
        ///     Additional calls to this function after successful initialization but before
        ///     termination will return `GLFW_TRUE` immediately.
        /// </summary>
        /// <returns>
        ///     `GLFW_TRUE` if successful, or `GLFW_FALSE` if an
        ///     [error](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static int Init()
        {
            var ret = Public.Init_0();
            return ret;
        }

        /// <summary>
        ///     This function destroys all remaining windows and cursors, restores any
        ///     modified gamma ramps and frees any other allocated resources.  Once this
        ///     function is called, you must again call
        ///     you will be able to use most GLFW functions.
        ///     If GLFW has been successfully initialized, this function should be called
        ///     before the application exits.  If initialization fails, there is no need to
        ///     call this function, as it is called by
        ///     failure.
        ///     Possible errors include
        ///     This function must not be called from a callback.
        ///     _safety This function must only be called from the main thread.
        /// </summary>
        public static void Terminate()
        {
            Public.Terminate_0();
        }

        public static Test GetTests()
        {
            var ret = Public.GetTests_0();
            Test result0;
            if (ret == IntPtr.Zero) result0 = null;
            else if (Test.NativeToManagedMap.ContainsKey(ret))
                result0 = Test.NativeToManagedMap[ret];
            else result0 = Test.__CreateInstance(ret);
            return result0;
        }

        /// <summary>
        ///     This function retrieves the major, minor and revision numbers of the GLFW
        ///     library.  It is intended for when you are using GLFW as a shared library and
        ///     want to ensure that you are using the minimum required version.
        ///     Any or all of the version arguments may be `NULL`.
        /// </summary>
        /// <param name="major">Where to store the major version number, or `NULL`.</param>
        /// <param name="minor">Where to store the minor version number, or `NULL`.</param>
        /// <param name="rev">
        ///     Where to store the revision number, or `NULL`.
        ///     None.
        ///     _safety This function may be called from any thread.
        /// </param>
        public static void GetVersion(ref int major, ref int minor, ref int rev)
        {
            fixed (int* refParamPtr0 = &major)
            {
                var arg0 = refParamPtr0;
                fixed (int* refParamPtr1 = &minor)
                {
                    var arg1 = refParamPtr1;
                    fixed (int* refParamPtr2 = &rev)
                    {
                        var arg2 = refParamPtr2;
                        Public.GetVersion_0(arg0, arg1, arg2);
                    }
                }
            }
        }

        /// <summary>
        ///     This function returns the compile-time generated
        ///     [version string](
        ///     describes the version, platform, compiler and any platform-specific
        ///     compile-time options.  It should not be confused with the OpenGL or OpenGL
        ///     ES version string, queried with `glGetString`.
        ///     __Do not use the version string__ to parse the GLFW library version.  The
        ///     binary in numerical format.
        /// </summary>
        /// <returns>
        ///     The ASCII encoded GLFW version string.
        ///     None.
        ///     _lifetime The returned string is static and compile-time generated.
        ///     _safety This function may be called from any thread.
        /// </returns>
        public static string GetVersionString()
        {
            var ret = Public.GetVersionString_0();
            return Marshal.PtrToStringAnsi(ret);
        }

        /// <summary>
        ///     This function sets the error callback, which is called with an error code
        ///     and a human-readable description each time a GLFW error occurs.
        ///     The error callback is called on the thread where the error occurred.  If you
        ///     are using GLFW from multiple threads, your error callback needs to be
        ///     written accordingly.
        ///     Because the description string may have been generated specifically for that
        ///     error, it is not guaranteed to be valid after the callback has returned.  If
        ///     you wish to use it after the callback returns, you need to make a copy.
        ///     Once set, the error callback remains set even after the library has been
        ///     terminated.
        /// </summary>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set.
        ///     None.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWerrorfun SetErrorCallback(GlfWerrorfun cbfun)
        {
            var arg0 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetErrorCallback_0(arg0);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWerrorfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWerrorfun));
        }

        /// <summary>
        ///     This function returns an array of handles for all currently connected
        ///     monitors.  The primary monitor is always first in the returned array.  If no
        ///     monitors were found, this function returns `NULL`.
        /// </summary>
        /// <param name="count">
        ///     Where to store the number of monitors in the returned
        ///     array.  This is set to zero if an error occurred.
        /// </param>
        /// <returns>
        ///     An array of monitor handles, or `NULL` if no monitors were found or
        ///     if an [error](
        ///     Possible errors include
        ///     _lifetime The returned array is allocated and freed by GLFW.  You
        ///     should not free it yourself.  It is guaranteed to be valid only until the
        ///     monitor configuration changes or the library is terminated.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWmonitor GetMonitors(ref int count)
        {
            fixed (int* refParamPtr0 = &count)
            {
                var arg0 = refParamPtr0;
                var ret = Public.GetMonitors_0(arg0);
                GlfWmonitor result0;
                if (ret == IntPtr.Zero) result0 = null;
                else if (GlfWmonitor.NativeToManagedMap.ContainsKey(ret))
                    result0 = GlfWmonitor.NativeToManagedMap[ret];
                else result0 = GlfWmonitor.__CreateInstance(ret);
                return result0;
            }
        }

        /// <summary>
        ///     This function returns the primary monitor.  This is usually the monitor
        ///     where elements like the task bar or global menu bar are located.
        /// </summary>
        /// <returns>
        ///     The primary monitor, or `NULL` if no monitors were found or if an
        ///     [error](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        ///     glfwGetMonitors.
        /// </returns>
        public static GlfWmonitor GetPrimaryMonitor()
        {
            var ret = Public.GetPrimaryMonitor_0();
            GlfWmonitor result0;
            if (ret == IntPtr.Zero) result0 = null;
            else if (GlfWmonitor.NativeToManagedMap.ContainsKey(ret))
                result0 = GlfWmonitor.NativeToManagedMap[ret];
            else result0 = GlfWmonitor.__CreateInstance(ret);
            return result0;
        }

        /// <summary>
        ///     This function returns the position, in screen coordinates, of the upper-left
        ///     corner of the specified monitor.
        ///     Any or all of the position arguments may be `NULL`.  If an error occurs, all
        ///     non-`NULL` position arguments will be set to zero.
        /// </summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="xpos">Where to store the monitor x-coordinate, or `NULL`.</param>
        /// <param name="ypos">
        ///     Where to store the monitor y-coordinate, or `NULL`.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void GetMonitorPos(GlfWmonitor monitor, ref int xpos, ref int ypos)
        {
            var arg0 = monitor?.Instance ?? IntPtr.Zero;
            fixed (int* refParamPtr1 = &xpos)
            {
                var arg1 = refParamPtr1;
                fixed (int* refParamPtr2 = &ypos)
                {
                    var arg2 = refParamPtr2;
                    Public.GetMonitorPos_0(arg0, arg1, arg2);
                }
            }
        }

        /// <summary>
        ///     This function returns the size, in millimetres, of the display area of the
        ///     specified monitor.
        ///     Some systems do not provide accurate monitor size information, either
        ///     because the monitor
        ///     [EDID](https://en.wikipedia.org/wiki/Extended_display_identification_data)
        ///     data is incorrect or because the driver does not report it accurately.
        ///     Any or all of the size arguments may be `NULL`.  If an error occurs, all
        ///     non-`NULL` size arguments will be set to zero.
        /// </summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="widthMm">
        ///     Where to store the width, in millimetres, of the
        ///     monitor's display area, or `NULL`.
        /// </param>
        /// <param name="heightMm">
        ///     Where to store the height, in millimetres, of the
        ///     monitor's display area, or `NULL`.
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void GetMonitorPhysicalSize(GlfWmonitor monitor, ref int widthMm, ref int heightMm)
        {
            var arg0 = monitor?.Instance ?? IntPtr.Zero;
            fixed (int* refParamPtr1 = &widthMm)
            {
                var arg1 = refParamPtr1;
                fixed (int* refParamPtr2 = &heightMm)
                {
                    var arg2 = refParamPtr2;
                    Public.GetMonitorPhysicalSize_0(arg0, arg1, arg2);
                }
            }
        }

        /// <summary>
        ///     This function returns a human-readable name, encoded as UTF-8, of the
        ///     specified monitor.  The name typically reflects the make and model of the
        ///     monitor and is not guaranteed to be unique among the connected monitors.
        /// </summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <returns>
        ///     The UTF-8 encoded name of the monitor, or `NULL` if an
        ///     [error](
        ///     Possible errors include
        ///     _lifetime The returned string is allocated and freed by GLFW.  You
        ///     should not free it yourself.  It is valid until the specified monitor is
        ///     disconnected or the library is terminated.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static string GetMonitorName(GlfWmonitor monitor)
        {
            var arg0 = monitor?.Instance ?? IntPtr.Zero;
            var ret = Public.GetMonitorName_0(arg0);
            return Marshal.PtrToStringAnsi(ret);
        }

        /// <summary>
        ///     This function sets the monitor configuration callback, or removes the
        ///     currently set callback.  This is called when a monitor is connected to or
        ///     disconnected from the system.
        /// </summary>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWmonitorfun SetMonitorCallback(GlfWmonitorfun cbfun)
        {
            var arg0 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetMonitorCallback_0(arg0);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWmonitorfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWmonitorfun));
        }

        /// <summary>
        ///     This function returns an array of all video modes supported by the specified
        ///     monitor.  The returned array is sorted in ascending order, first by color
        ///     bit depth (the sum of all channel depths) and then by resolution area (the
        ///     product of width and height).
        /// </summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <param name="count">
        ///     Where to store the number of video modes in the returned
        ///     array.  This is set to zero if an error occurred.
        /// </param>
        /// <returns>
        ///     An array of video modes, or `NULL` if an
        ///     [error](
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _lifetime The returned array is allocated and freed by GLFW.  You
        ///     should not free it yourself.  It is valid until the specified monitor is
        ///     disconnected, this function is called again for that monitor or the library
        ///     is terminated.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWvidmode GetVideoModes(GlfWmonitor monitor, ref int count)
        {
            var arg0 = monitor?.Instance ?? IntPtr.Zero;
            fixed (int* refParamPtr1 = &count)
            {
                var arg1 = refParamPtr1;
                var ret = Public.GetVideoModes_0(arg0, arg1);
                GlfWvidmode result0;
                if (ret == IntPtr.Zero) result0 = null;
                else if (GlfWvidmode.NativeToManagedMap.ContainsKey(ret))
                    result0 = GlfWvidmode.NativeToManagedMap[ret];
                else result0 = GlfWvidmode.__CreateInstance(ret);
                return result0;
            }
        }

        /// <summary>
        ///     This function returns the current video mode of the specified monitor.  If
        ///     you have created a full screen window for that monitor, the return value
        ///     will depend on whether that window is iconified.
        /// </summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <returns>
        ///     The current mode of the monitor, or `NULL` if an
        ///     [error](
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _lifetime The returned array is allocated and freed by GLFW.  You
        ///     should not free it yourself.  It is valid until the specified monitor is
        ///     disconnected or the library is terminated.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWvidmode GetVideoMode(GlfWmonitor monitor)
        {
            var arg0 = monitor?.Instance ?? IntPtr.Zero;
            var ret = Public.GetVideoMode_0(arg0);
            GlfWvidmode result0;
            if (ret == IntPtr.Zero) result0 = null;
            else if (GlfWvidmode.NativeToManagedMap.ContainsKey(ret))
                result0 = GlfWvidmode.NativeToManagedMap[ret];
            else result0 = GlfWvidmode.__CreateInstance(ret);
            return result0;
        }

        /// <summary>
        ///     This function generates a 256-element gamma ramp from the specified exponent
        ///     and then calls
        ///     number greater than zero.
        /// </summary>
        /// <param name="monitor">The monitor whose gamma ramp to set.</param>
        /// <param name="gamma">
        ///     The desired exponent.
        ///     Possible errors include
        ///     GLFW_INVALID_VALUE and
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetGamma(GlfWmonitor monitor, float gamma)
        {
            var arg0 = monitor?.Instance ?? IntPtr.Zero;
            Public.SetGamma_0(arg0, gamma);
        }

        /// <summary>  This function returns the current gamma ramp of the specified monitor.</summary>
        /// <param name="monitor">The monitor to query.</param>
        /// <returns>
        ///     The current gamma ramp, or `NULL` if an
        ///     [error](
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _lifetime The returned structure and its arrays are allocated and
        ///     freed by GLFW.  You should not free them yourself.  They are valid until the
        ///     specified monitor is disconnected, this function is called again for that
        ///     monitor or the library is terminated.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWgammaramp GetGammaRamp(GlfWmonitor monitor)
        {
            var arg0 = monitor?.Instance ?? IntPtr.Zero;
            var ret = Public.GetGammaRamp_0(arg0);
            GlfWgammaramp result0;
            if (ret == IntPtr.Zero) result0 = null;
            else if (GlfWgammaramp.NativeToManagedMap.ContainsKey(ret))
                result0 = GlfWgammaramp.NativeToManagedMap[ret];
            else result0 = GlfWgammaramp.__CreateInstance(ret);
            return result0;
        }

        /// <summary>
        ///     This function sets the current gamma ramp for the specified monitor.  The
        ///     original gamma ramp for that monitor is saved by GLFW the first time this
        ///     function is called and is restored by
        /// </summary>
        /// <param name="monitor">The monitor whose gamma ramp to set.</param>
        /// <param name="ramp">
        ///     The gamma ramp to use.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _lifetime The specified gamma ramp is copied before this function
        ///     returns.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetGammaRamp(GlfWmonitor monitor, GlfWgammaramp ramp)
        {
            var arg0 = monitor?.Instance ?? IntPtr.Zero;
            var arg1 = ramp?.Instance ?? IntPtr.Zero;
            Public.SetGammaRamp_0(arg0, arg1);
        }

        /// <summary>
        ///     This function resets all window hints to their
        ///     [default values](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </summary>
        public static void DefaultWindowHints()
        {
            Public.DefaultWindowHints_0();
        }

        /// <summary>
        ///     This function sets hints for the next call to
        ///     hints, once set, retain their values until changed by a call to
        ///     glfwWindowHint or
        ///     terminated.
        ///     This function does not check whether the specified hint values are valid.
        ///     If you set hints to invalid values this will instead be reported by the next
        ///     call to
        /// </summary>
        /// <param name="hint">The [window hint](</param>
        /// <param name="value">
        ///     The new value of the window hint.
        ///     Possible errors include
        ///     GLFW_INVALID_ENUM.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void WindowHint(int hint, int value)
        {
            Public.WindowHint_0(hint, value);
        }

        /// <summary>
        ///     This function creates a window and its associated OpenGL or OpenGL ES
        ///     context.  Most of the options controlling how the window and its context
        ///     should be created are specified with [window hints](
        ///     Successful creation does not change which context is current.  Before you
        ///     can use the newly created context, you need to
        ///     [make it current](
        ///     parameter, see
        ///     The created window, framebuffer and context may differ from what you
        ///     requested, as not all parameters and hints are
        ///     [hard constraints](
        ///     window, especially for full screen windows.  To query the actual attributes
        ///     of the created window, framebuffer and context, see
        ///     glfwGetWindowAttrib,
        ///     To create a full screen window, you need to specify the monitor the window
        ///     will cover.  If no monitor is specified, the window will be windowed mode.
        ///     Unless you have a way for the user to choose a specific monitor, it is
        ///     recommended that you pick the primary monitor.  For more information on how
        ///     to query connected monitors, see
        ///     For full screen windows, the specified size becomes the resolution of the
        ///     window's _desired video mode_.  As long as a full screen window is not
        ///     iconified, the supported video mode most closely matching the desired video
        ///     mode is set for the specified monitor.  For more information about full
        ///     screen windows, including the creation of so called _windowed full screen_
        ///     or _borderless full screen_ windows, see
        ///     Once you have created the window, you can switch it between windowed and
        ///     full screen mode with
        ///     OpenGL or OpenGL ES context, it will be unaffected.
        ///     By default, newly created windows use the placement recommended by the
        ///     window system.  To create the window at a specific position, make it
        ///     initially invisible using the [GLFW_VISIBLE](
        ///     hint, set its [position](
        ///     it.
        ///     As long as at least one full screen window is not iconified, the screensaver
        ///     is prohibited from starting.
        ///     Window systems put limits on window sizes.  Very large or very small window
        ///     dimensions may be overridden by the window system on creation.  Check the
        ///     actual [size](
        ///     The [swap interval](
        ///     the initial value may vary depending on driver settings and defaults.
        /// </summary>
        /// <param name="width">
        ///     The desired width, in screen coordinates, of the window.
        ///     This must be greater than zero.
        /// </param>
        /// <param name="height">
        ///     The desired height, in screen coordinates, of the window.
        ///     This must be greater than zero.
        /// </param>
        /// <param name="title">The initial, UTF-8 encoded window title.</param>
        /// <param name="monitor">
        ///     The monitor to use for full screen mode, or `NULL` for
        ///     windowed mode.
        /// </param>
        /// <param name="share">
        ///     The window whose context to share resources with, or `NULL`
        ///     to not share resources.
        /// </param>
        /// <returns>
        ///     The handle of the created window, or `NULL` if an
        ///     [error](
        ///     Possible errors include
        ///     GLFW_INVALID_ENUM,
        ///     GLFW_VERSION_UNAVAILABLE,
        ///     GLFW_PLATFORM_ERROR.
        ///     This function must not be called from a callback.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWwindow CreateWindow(int width, int height, string title, GlfWmonitor monitor, GlfWwindow share)
        {
            var arg3 = monitor?.Instance ?? IntPtr.Zero;
            var arg4 = share?.Instance ?? IntPtr.Zero;
            var ret = Public.CreateWindow_0(width, height, title, arg3, arg4);
            GlfWwindow result0;
            if (ret == IntPtr.Zero) result0 = null;
            else result0 = GlfWwindow.__CreateInstance(ret);
            return result0;
        }

        /// <summary>
        ///     This function destroys the specified window and its context.  On calling
        ///     this function, no further callbacks will be called for that window.
        ///     If the context of the specified window is current on the main thread, it is
        ///     detached before being destroyed.
        /// </summary>
        /// <param name="window">
        ///     The window to destroy.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     This function must not be called from a callback.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void DestroyWindow(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.DestroyWindow_0(arg0);
        }

        /// <summary>  This function returns the value of the close flag of the specified window.</summary>
        /// <param name="window">The window to query.</param>
        /// <returns>
        ///     The value of the close flag.
        ///     Possible errors include
        ///     _safety This function may be called from any thread.  Access is not
        ///     synchronized.
        /// </returns>
        public static int WindowShouldClose(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var ret = Public.WindowShouldClose_0(arg0);
            return ret;
        }

        /// <summary>
        ///     This function sets the value of the close flag of the specified window.
        ///     This can be used to override the user's attempt to close the window, or
        ///     to signal that it should be closed.
        /// </summary>
        /// <param name="window">The window whose flag to change.</param>
        /// <param name="value">
        ///     The new value.
        ///     Possible errors include
        ///     _safety This function may be called from any thread.  Access is not
        ///     synchronized.
        /// </param>
        public static void SetWindowShouldClose(GlfWwindow window, int value)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.SetWindowShouldClose_0(arg0, value);
        }

        /// <summary>
        ///     This function sets the window title, encoded as UTF-8, of the specified
        ///     window.
        /// </summary>
        /// <param name="window">The window whose title to change.</param>
        /// <param name="title">
        ///     The UTF-8 encoded window title.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowTitle(GlfWwindow window, string title)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.SetWindowTitle_0(arg0, title);
        }

        /// <summary>
        ///     This function sets the icon of the specified window.  If passed an array of
        ///     candidate images, those of or closest to the sizes desired by the system are
        ///     selected.  If no images are specified, the window reverts to its default
        ///     icon.
        ///     The desired image sizes varies depending on platform and system settings.
        ///     The selected images will be rescaled as needed.  Good sizes include 16x16,
        ///     32x32 and 48x48.
        /// </summary>
        /// <param name="window">The window whose icon to set.</param>
        /// <param name="count">
        ///     The number of images in the specified array, or zero to
        ///     revert to the default window icon.
        /// </param>
        /// <param name="images">
        ///     The images to create the icon from.  This is ignored if
        ///     count is zero.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _lifetime The specified image data is copied before this function
        ///     returns.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowIcon(GlfWwindow window, int count, GlfWimage images)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg2 = images?.Instance ?? IntPtr.Zero;
            Public.SetWindowIcon_0(arg0, count, arg2);
        }

        /// <summary>
        ///     This function retrieves the position, in screen coordinates, of the
        ///     upper-left corner of the client area of the specified window.
        ///     Any or all of the position arguments may be `NULL`.  If an error occurs, all
        ///     non-`NULL` position arguments will be set to zero.
        /// </summary>
        /// <param name="window">The window to query.</param>
        /// <param name="xpos">
        ///     Where to store the x-coordinate of the upper-left corner of
        ///     the client area, or `NULL`.
        /// </param>
        /// <param name="ypos">
        ///     Where to store the y-coordinate of the upper-left corner of
        ///     the client area, or `NULL`.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void GetWindowPos(GlfWwindow window, ref int xpos, ref int ypos)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            fixed (int* refParamPtr1 = &xpos)
            {
                var arg1 = refParamPtr1;
                fixed (int* refParamPtr2 = &ypos)
                {
                    var arg2 = refParamPtr2;
                    Public.GetWindowPos_0(arg0, arg1, arg2);
                }
            }
        }

        /// <summary>
        ///     This function sets the position, in screen coordinates, of the upper-left
        ///     corner of the client area of the specified windowed mode window.  If the
        ///     window is a full screen window, this function does nothing.
        ///     __Do not use this function__ to move an already visible window unless you
        ///     have very good reasons for doing so, as it will confuse and annoy the user.
        ///     The window manager may put limits on what positions are allowed.  GLFW
        ///     cannot and should not override these limits.
        /// </summary>
        /// <param name="window">The window to query.</param>
        /// <param name="xpos">The x-coordinate of the upper-left corner of the client area.</param>
        /// <param name="ypos">
        ///     The y-coordinate of the upper-left corner of the client area.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowPos(GlfWwindow window, int xpos, int ypos)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.SetWindowPos_0(arg0, xpos, ypos);
        }

        /// <summary>
        ///     This function retrieves the size, in screen coordinates, of the client area
        ///     of the specified window.  If you wish to retrieve the size of the
        ///     framebuffer of the window in pixels, see
        ///     Any or all of the size arguments may be `NULL`.  If an error occurs, all
        ///     non-`NULL` size arguments will be set to zero.
        /// </summary>
        /// <param name="window">The window whose size to retrieve.</param>
        /// <param name="width">
        ///     Where to store the width, in screen coordinates, of the
        ///     client area, or `NULL`.
        /// </param>
        /// <param name="height">
        ///     Where to store the height, in screen coordinates, of the
        ///     client area, or `NULL`.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void GetWindowSize(GlfWwindow window, ref int width, ref int height)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            fixed (int* refParamPtr1 = &width)
            {
                var arg1 = refParamPtr1;
                fixed (int* refParamPtr2 = &height)
                {
                    var arg2 = refParamPtr2;
                    Public.GetWindowSize_0(arg0, arg1, arg2);
                }
            }
        }

        /// <summary>
        ///     This function sets the size limits of the client area of the specified
        ///     window.  If the window is full screen, the size limits only take effect
        ///     once it is made windowed.  If the window is not resizable, this function
        ///     does nothing.
        ///     The size limits are applied immediately to a windowed mode window and may
        ///     cause it to be resized.
        ///     The maximum dimensions must be greater than or equal to the minimum
        ///     dimensions and all must be greater than or equal to zero.
        /// </summary>
        /// <param name="window">The window to set limits for.</param>
        /// <param name="minwidth">
        ///     The minimum width, in screen coordinates, of the client
        ///     area, or `GLFW_DONT_CARE`.
        /// </param>
        /// <param name="minheight">
        ///     The minimum height, in screen coordinates, of the
        ///     client area, or `GLFW_DONT_CARE`.
        /// </param>
        /// <param name="maxwidth">
        ///     The maximum width, in screen coordinates, of the client
        ///     area, or `GLFW_DONT_CARE`.
        /// </param>
        /// <param name="maxheight">
        ///     The maximum height, in screen coordinates, of the
        ///     client area, or `GLFW_DONT_CARE`.
        ///     Possible errors include
        ///     GLFW_INVALID_VALUE and
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowSizeLimits(GlfWwindow window, int minwidth, int minheight, int maxwidth, int maxheight)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.SetWindowSizeLimits_0(arg0, minwidth, minheight, maxwidth, maxheight);
        }

        /// <summary>
        ///     This function sets the required aspect ratio of the client area of the
        ///     specified window.  If the window is full screen, the aspect ratio only takes
        ///     effect once it is made windowed.  If the window is not resizable, this
        ///     function does nothing.
        ///     The aspect ratio is specified as a numerator and a denominator and both
        ///     values must be greater than zero.  For example, the common 16:9 aspect ratio
        ///     is specified as 16 and 9, respectively.
        ///     If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect
        ///     ratio limit is disabled.
        ///     The aspect ratio is applied immediately to a windowed mode window and may
        ///     cause it to be resized.
        /// </summary>
        /// <param name="window">The window to set limits for.</param>
        /// <param name="numer">
        ///     The numerator of the desired aspect ratio, or
        ///     `GLFW_DONT_CARE`.
        /// </param>
        /// <param name="denom">
        ///     The denominator of the desired aspect ratio, or
        ///     `GLFW_DONT_CARE`.
        ///     Possible errors include
        ///     GLFW_INVALID_VALUE and
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowAspectRatio(GlfWwindow window, int numer, int denom)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.SetWindowAspectRatio_0(arg0, numer, denom);
        }

        /// <summary>
        ///     This function sets the size, in screen coordinates, of the client area of
        ///     the specified window.
        ///     For full screen windows, this function updates the resolution of its desired
        ///     video mode and switches to the video mode closest to it, without affecting
        ///     the window's context.  As the context is unaffected, the bit depths of the
        ///     framebuffer remain unchanged.
        ///     If you wish to update the refresh rate of the desired video mode in addition
        ///     to its resolution, see
        ///     The window manager may put limits on what sizes are allowed.  GLFW cannot
        ///     and should not override these limits.
        /// </summary>
        /// <param name="window">The window to resize.</param>
        /// <param name="width">
        ///     The desired width, in screen coordinates, of the window
        ///     client area.
        /// </param>
        /// <param name="height">
        ///     The desired height, in screen coordinates, of the window
        ///     client area.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowSize(GlfWwindow window, int width, int height)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.SetWindowSize_0(arg0, width, height);
        }

        /// <summary>
        ///     This function retrieves the size, in pixels, of the framebuffer of the
        ///     specified window.  If you wish to retrieve the size of the window in screen
        ///     coordinates, see
        ///     Any or all of the size arguments may be `NULL`.  If an error occurs, all
        ///     non-`NULL` size arguments will be set to zero.
        /// </summary>
        /// <param name="window">The window whose framebuffer to query.</param>
        /// <param name="width">
        ///     Where to store the width, in pixels, of the framebuffer,
        ///     or `NULL`.
        /// </param>
        /// <param name="height">
        ///     Where to store the height, in pixels, of the framebuffer,
        ///     or `NULL`.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void GetFramebufferSize(GlfWwindow window, ref int width, ref int height)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            fixed (int* refParamPtr1 = &width)
            {
                var arg1 = refParamPtr1;
                fixed (int* refParamPtr2 = &height)
                {
                    var arg2 = refParamPtr2;
                    Public.GetFramebufferSize_0(arg0, arg1, arg2);
                }
            }
        }

        /// <summary>
        ///     This function retrieves the size, in screen coordinates, of each edge of the
        ///     frame of the specified window.  This size includes the title bar, if the
        ///     window has one.  The size of the frame may vary depending on the
        ///     [window-related hints](
        ///     Because this function retrieves the size of each window frame edge and not
        ///     the offset along a particular coordinate axis, the retrieved values will
        ///     always be zero or positive.
        ///     Any or all of the size arguments may be `NULL`.  If an error occurs, all
        ///     non-`NULL` size arguments will be set to zero.
        /// </summary>
        /// <param name="window">The window whose frame size to query.</param>
        /// <param name="left">
        ///     Where to store the size, in screen coordinates, of the left
        ///     edge of the window frame, or `NULL`.
        /// </param>
        /// <param name="top">
        ///     Where to store the size, in screen coordinates, of the top
        ///     edge of the window frame, or `NULL`.
        /// </param>
        /// <param name="right">
        ///     Where to store the size, in screen coordinates, of the
        ///     right edge of the window frame, or `NULL`.
        /// </param>
        /// <param name="bottom">
        ///     Where to store the size, in screen coordinates, of the
        ///     bottom edge of the window frame, or `NULL`.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void GetWindowFrameSize(GlfWwindow window, ref int left, ref int top, ref int right, ref int bottom)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            fixed (int* refParamPtr1 = &left)
            {
                var arg1 = refParamPtr1;
                fixed (int* refParamPtr2 = &top)
                {
                    var arg2 = refParamPtr2;
                    fixed (int* refParamPtr3 = &right)
                    {
                        var arg3 = refParamPtr3;
                        fixed (int* refParamPtr4 = &bottom)
                        {
                            var arg4 = refParamPtr4;
                            Public.GetWindowFrameSize_0(arg0, arg1, arg2, arg3, arg4);
                        }
                    }
                }
            }
        }

        /// <summary>
        ///     This function iconifies (minimizes) the specified window if it was
        ///     previously restored.  If the window is already iconified, this function does
        ///     nothing.
        ///     If the specified window is a full screen window, the original monitor
        ///     resolution is restored until the window is restored.
        /// </summary>
        /// <param name="window">
        ///     The window to iconify.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void IconifyWindow(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.IconifyWindow_0(arg0);
        }

        /// <summary>
        ///     This function restores the specified window if it was previously iconified
        ///     (minimized) or maximized.  If the window is already restored, this function
        ///     does nothing.
        ///     If the specified window is a full screen window, the resolution chosen for
        ///     the window is restored on the selected monitor.
        /// </summary>
        /// <param name="window">
        ///     The window to restore.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void RestoreWindow(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.RestoreWindow_0(arg0);
        }

        /// <summary>
        ///     This function maximizes the specified window if it was previously not
        ///     maximized.  If the window is already maximized, this function does nothing.
        ///     If the specified window is a full screen window, this function does nothing.
        /// </summary>
        /// <param name="window">
        ///     The window to maximize.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        /// </param>
        public static void MaximizeWindow(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.MaximizeWindow_0(arg0);
        }

        /// <summary>
        ///     This function makes the specified window visible if it was previously
        ///     hidden.  If the window is already visible or is in full screen mode, this
        ///     function does nothing.
        /// </summary>
        /// <param name="window">
        ///     The window to make visible.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void ShowWindow(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.ShowWindow_0(arg0);
        }

        /// <summary>
        ///     This function hides the specified window if it was previously visible.  If
        ///     the window is already hidden or is in full screen mode, this function does
        ///     nothing.
        /// </summary>
        /// <param name="window">
        ///     The window to hide.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void HideWindow(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.HideWindow_0(arg0);
        }

        /// <summary>
        ///     This function brings the specified window to front and sets input focus.
        ///     The window should already be visible and not iconified.
        ///     By default, both windowed and full screen mode windows are focused when
        ///     initially created.  Set the [GLFW_FOCUSED](
        ///     this behavior.
        ///     __Do not use this function__ to steal focus from other applications unless
        ///     you are certain that is what the user wants.  Focus stealing can be
        ///     extremely disruptive.
        /// </summary>
        /// <param name="window">
        ///     The window to give input focus.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void FocusWindow(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.FocusWindow_0(arg0);
        }

        /// <summary>
        ///     This function returns the handle of the monitor that the specified window is
        ///     in full screen on.
        /// </summary>
        /// <param name="window">The window to query.</param>
        /// <returns>
        ///     The monitor, or `NULL` if the window is in windowed mode or an
        ///     [error](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWmonitor GetWindowMonitor(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var ret = Public.GetWindowMonitor_0(arg0);
            GlfWmonitor result0;
            if (ret == IntPtr.Zero) result0 = null;
            else if (GlfWmonitor.NativeToManagedMap.ContainsKey(ret))
                result0 = GlfWmonitor.NativeToManagedMap[ret];
            else result0 = GlfWmonitor.__CreateInstance(ret);
            return result0;
        }

        /// <summary>
        ///     This function sets the monitor that the window uses for full screen mode or,
        ///     if the monitor is `NULL`, makes it windowed mode.
        ///     When setting a monitor, this function updates the width, height and refresh
        ///     rate of the desired video mode and switches to the video mode closest to it.
        ///     The window position is ignored when setting a monitor.
        ///     When the monitor is `NULL`, the position, width and height are used to
        ///     place the window client area.  The refresh rate is ignored when no monitor
        ///     is specified.
        ///     If you only wish to update the resolution of a full screen window or the
        ///     size of a windowed mode window, see
        ///     When a window transitions from full screen to windowed mode, this function
        ///     restores any previous window settings such as whether it is decorated,
        ///     floating, resizable, has size or aspect ratio limits, etc..
        /// </summary>
        /// <param name="window">The window whose monitor, size or video mode to set.</param>
        /// <param name="monitor">The desired monitor, or `NULL` to set windowed mode.</param>
        /// <param name="xpos">
        ///     The desired x-coordinate of the upper-left corner of the
        ///     client area.
        /// </param>
        /// <param name="ypos">
        ///     The desired y-coordinate of the upper-left corner of the
        ///     client area.
        /// </param>
        /// <param name="width">
        ///     The desired with, in screen coordinates, of the client area
        ///     or video mode.
        /// </param>
        /// <param name="height">
        ///     The desired height, in screen coordinates, of the client
        ///     area or video mode.
        /// </param>
        /// <param name="refreshRate">
        ///     The desired refresh rate, in Hz, of the video mode,
        ///     or `GLFW_DONT_CARE`.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetWindowMonitor(GlfWwindow window, GlfWmonitor monitor, int xpos, int ypos, int width, int height, int refreshRate)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = monitor?.Instance ?? IntPtr.Zero;
            Public.SetWindowMonitor_0(arg0, arg1, xpos, ypos, width, height, refreshRate);
        }

        /// <summary>
        ///     This function returns the value of an attribute of the specified window or
        ///     its OpenGL or OpenGL ES context.
        /// </summary>
        /// <param name="window">The window to query.</param>
        /// <param name="attrib">
        ///     The [window attribute](
        ///     return.
        /// </param>
        /// <returns>
        ///     The value of the attribute, or zero if an
        ///     [error](
        ///     Possible errors include
        ///     GLFW_INVALID_ENUM and
        ///     window_attribs_fb for more information.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static int GetWindowAttrib(GlfWwindow window, int attrib)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var ret = Public.GetWindowAttrib_0(arg0, attrib);
            return ret;
        }

        /// <summary>
        ///     This function sets the user-defined pointer of the specified window.  The
        ///     current value is retained until the window is destroyed.  The initial value
        ///     is `NULL`.
        /// </summary>
        /// <param name="window">The window whose pointer to set.</param>
        /// <param name="pointer">
        ///     The new value.
        ///     Possible errors include
        ///     _safety This function may be called from any thread.  Access is not
        ///     synchronized.
        /// </param>
        public static void SetWindowUserPointer(GlfWwindow window, IntPtr pointer)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.SetWindowUserPointer_0(arg0, pointer);
        }

        /// <summary>
        ///     This function returns the current value of the user-defined pointer of the
        ///     specified window.  The initial value is `NULL`.
        /// </summary>
        /// <param name="window">
        ///     The window whose pointer to return.
        ///     Possible errors include
        ///     _safety This function may be called from any thread.  Access is not
        ///     synchronized.
        /// </param>
        public static IntPtr GetWindowUserPointer(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var ret = Public.GetWindowUserPointer_0(arg0);
            return ret;
        }

        /// <summary>
        ///     This function sets the position callback of the specified window, which is
        ///     called when the window is moved.  The callback is provided with the screen
        ///     position of the upper-left corner of the client area of the window.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWwindowposfun SetWindowPosCallback(GlfWwindow window, GlfWwindowposfun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetWindowPosCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWwindowposfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWwindowposfun));
        }

        /// <summary>
        ///     This function sets the size callback of the specified window, which is
        ///     called when the window is resized.  The callback is provided with the size,
        ///     in screen coordinates, of the client area of the window.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWwindowsizefun SetWindowSizeCallback(GlfWwindow window, GlfWwindowsizefun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetWindowSizeCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWwindowsizefun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWwindowsizefun));
        }

        /// <summary>
        ///     This function sets the close callback of the specified window, which is
        ///     called when the user attempts to close the window, for example by clicking
        ///     the close widget in the title bar.
        ///     The close flag is set before this callback is called, but you can modify it
        ///     at any time with
        ///     The close callback is not triggered by
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWwindowclosefun SetWindowCloseCallback(GlfWwindow window, GlfWwindowclosefun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetWindowCloseCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWwindowclosefun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWwindowclosefun));
        }

        /// <summary>
        ///     This function sets the refresh callback of the specified window, which is
        ///     called when the client area of the window needs to be redrawn, for example
        ///     if the window has been exposed after having been covered by another window.
        ///     On compositing window systems such as Aero, Compiz or Aqua, where the window
        ///     contents are saved off-screen, this callback may be called only very
        ///     infrequently or never at all.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWwindowrefreshfun SetWindowRefreshCallback(GlfWwindow window, GlfWwindowrefreshfun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetWindowRefreshCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWwindowrefreshfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWwindowrefreshfun));
        }

        /// <summary>
        ///     This function sets the focus callback of the specified window, which is
        ///     called when the window gains or loses input focus.
        ///     After the focus callback is called for a window that lost input focus,
        ///     synthetic key and mouse button release events will be generated for all such
        ///     that had been pressed.  For more information, see
        ///     and
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWwindowfocusfun SetWindowFocusCallback(GlfWwindow window, GlfWwindowfocusfun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetWindowFocusCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWwindowfocusfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWwindowfocusfun));
        }

        /// <summary>
        ///     This function sets the iconification callback of the specified window, which
        ///     is called when the window is iconified or restored.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWwindowiconifyfun SetWindowIconifyCallback(GlfWwindow window, GlfWwindowiconifyfun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetWindowIconifyCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWwindowiconifyfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWwindowiconifyfun));
        }

        /// <summary>
        ///     This function sets the framebuffer resize callback of the specified window,
        ///     which is called when the framebuffer of the specified window is resized.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWframebuffersizefun SetFramebufferSizeCallback(GlfWwindow window, GlfWframebuffersizefun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetFramebufferSizeCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWframebuffersizefun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWframebuffersizefun));
        }

        /// <summary>
        ///     This function processes only those events that are already in the event
        ///     queue and then returns immediately.  Processing events will cause the window
        ///     and input callbacks associated with those events to be called.
        ///     On some platforms, a window move, resize or menu operation will cause event
        ///     processing to block.  This is due to how event processing is designed on
        ///     those platforms.  You can use the
        ///     [window refresh callback](
        ///     your window when necessary during such operations.
        ///     On some platforms, certain events are sent directly to the application
        ///     without going through the event queue, causing callbacks to be called
        ///     outside of a call to one of the event processing functions.
        ///     Event processing is not required for joystick input to work.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     This function must not be called from a callback.
        ///     _safety This function must only be called from the main thread.
        /// </summary>
        public static void PollEvents()
        {
            Public.PollEvents_0();
        }

        /// <summary>
        ///     This function puts the calling thread to sleep until at least one event is
        ///     available in the event queue.  Once one or more events are available,
        ///     it behaves exactly like
        ///     are processed and the function then returns immediately.  Processing events
        ///     will cause the window and input callbacks associated with those events to be
        ///     called.
        ///     Since not all events are associated with callbacks, this function may return
        ///     without a callback having been called even if you are monitoring all
        ///     callbacks.
        ///     On some platforms, a window move, resize or menu operation will cause event
        ///     processing to block.  This is due to how event processing is designed on
        ///     those platforms.  You can use the
        ///     [window refresh callback](
        ///     your window when necessary during such operations.
        ///     On some platforms, certain callbacks may be called outside of a call to one
        ///     of the event processing functions.
        ///     If no windows exist, this function returns immediately.  For synchronization
        ///     of threads in applications that do not create windows, use your threading
        ///     library of choice.
        ///     Event processing is not required for joystick input to work.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     This function must not be called from a callback.
        ///     _safety This function must only be called from the main thread.
        /// </summary>
        public static void WaitEvents()
        {
            Public.WaitEvents_0();
        }

        /// <summary>
        ///     This function puts the calling thread to sleep until at least one event is
        ///     available in the event queue, or until the specified timeout is reached.  If
        ///     one or more events are available, it behaves exactly like
        ///     glfwPollEvents, i.e. the events in the queue are processed and the function
        ///     then returns immediately.  Processing events will cause the window and input
        ///     callbacks associated with those events to be called.
        ///     The timeout value must be a positive finite number.
        ///     Since not all events are associated with callbacks, this function may return
        ///     without a callback having been called even if you are monitoring all
        ///     callbacks.
        ///     On some platforms, a window move, resize or menu operation will cause event
        ///     processing to block.  This is due to how event processing is designed on
        ///     those platforms.  You can use the
        ///     [window refresh callback](
        ///     your window when necessary during such operations.
        ///     On some platforms, certain callbacks may be called outside of a call to one
        ///     of the event processing functions.
        ///     If no windows exist, this function returns immediately.  For synchronization
        ///     of threads in applications that do not create windows, use your threading
        ///     library of choice.
        ///     Event processing is not required for joystick input to work.
        /// </summary>
        /// <param name="timeout">
        ///     The maximum amount of time, in seconds, to wait.
        ///     This function must not be called from a callback.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void WaitEventsTimeout(double timeout)
        {
            Public.WaitEventsTimeout_0(timeout);
        }

        /// <summary>
        ///     This function posts an empty event from the current thread to the event
        ///     queue, causing
        ///     If no windows exist, this function returns immediately.  For synchronization
        ///     of threads in applications that do not create windows, use your threading
        ///     library of choice.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function may be called from any thread.
        /// </summary>
        public static void PostEmptyEvent()
        {
            Public.PostEmptyEvent_0();
        }

        /// <summary>
        ///     This function returns the value of an input option for the specified window.
        ///     The mode must be one of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or
        ///     `GLFW_STICKY_MOUSE_BUTTONS`.
        /// </summary>
        /// <param name="window">The window to query.</param>
        /// <param name="mode">
        ///     One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or
        ///     `GLFW_STICKY_MOUSE_BUTTONS`.
        ///     Possible errors include
        ///     GLFW_INVALID_ENUM.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static int GetInputMode(GlfWwindow window, int mode)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var ret = Public.GetInputMode_0(arg0, mode);
            return ret;
        }

        /// <summary>
        ///     This function sets an input mode option for the specified window.  The mode
        ///     must be one of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or
        ///     `GLFW_STICKY_MOUSE_BUTTONS`.
        ///     If the mode is `GLFW_CURSOR`, the value must be one of the following cursor
        ///     modes:
        ///     - `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally.
        ///     - `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the client
        ///     area of the window but does not restrict the cursor from leaving.
        ///     - `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual
        ///     and unlimited cursor movement.  This is useful for implementing for
        ///     example 3D camera controls.
        ///     If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to
        ///     enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are
        ///     enabled, a key press will ensure that
        ///     the next time it is called even if the key had been released before the
        ///     call.  This is useful when you are only interested in whether keys have been
        ///     pressed but not when or in which order.
        ///     If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either
        ///     `GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it.
        ///     If sticky mouse buttons are enabled, a mouse button press will ensure that
        ///     if the mouse button had been released before the call.  This is useful when
        ///     you are only interested in whether mouse buttons have been pressed but not
        ///     when or in which order.
        /// </summary>
        /// <param name="window">The window whose input mode to set.</param>
        /// <param name="mode">
        ///     One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS` or
        ///     `GLFW_STICKY_MOUSE_BUTTONS`.
        /// </param>
        /// <param name="value">
        ///     The new value of the specified input mode.
        ///     Possible errors include
        ///     GLFW_INVALID_ENUM and
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetInputMode(GlfWwindow window, int mode, int value)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.SetInputMode_0(arg0, mode, value);
        }

        /// <summary>
        ///     This function returns the localized name of the specified printable key.
        ///     This is intended for displaying key bindings to the user.
        ///     If the key is `GLFW_KEY_UNKNOWN`, the scancode is used instead, otherwise
        ///     the scancode is ignored.  If a non-printable key or (if the key is
        ///     `GLFW_KEY_UNKNOWN`) a scancode that maps to a non-printable key is
        ///     specified, this function returns `NULL`.
        ///     This behavior allows you to pass in the arguments passed to the
        ///     [key callback](
        ///     The printable keys are:
        ///     - `GLFW_KEY_APOSTROPHE`
        ///     - `GLFW_KEY_COMMA`
        ///     - `GLFW_KEY_MINUS`
        ///     - `GLFW_KEY_PERIOD`
        ///     - `GLFW_KEY_SLASH`
        ///     - `GLFW_KEY_SEMICOLON`
        ///     - `GLFW_KEY_EQUAL`
        ///     - `GLFW_KEY_LEFT_BRACKET`
        ///     - `GLFW_KEY_RIGHT_BRACKET`
        ///     - `GLFW_KEY_BACKSLASH`
        ///     - `GLFW_KEY_WORLD_1`
        ///     - `GLFW_KEY_WORLD_2`
        ///     - `GLFW_KEY_0` to `GLFW_KEY_9`
        ///     - `GLFW_KEY_A` to `GLFW_KEY_Z`
        ///     - `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`
        ///     - `GLFW_KEY_KP_DECIMAL`
        ///     - `GLFW_KEY_KP_DIVIDE`
        ///     - `GLFW_KEY_KP_MULTIPLY`
        ///     - `GLFW_KEY_KP_SUBTRACT`
        ///     - `GLFW_KEY_KP_ADD`
        ///     - `GLFW_KEY_KP_EQUAL`
        /// </summary>
        /// <param name="key">The key to query, or `GLFW_KEY_UNKNOWN`.</param>
        /// <param name="scancode">The scancode of the key to query.</param>
        /// <returns>
        ///     The localized name of the key, or `NULL`.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _lifetime The returned string is allocated and freed by GLFW.  You
        ///     should not free it yourself.  It is valid until the next call to
        ///     glfwGetKeyName, or until the library is terminated.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static string GetKeyName(int key, int scancode)
        {
            var ret = Public.GetKeyName_0(key, scancode);
            return Marshal.PtrToStringAnsi(ret);
        }

        /// <summary>
        ///     This function returns the last state reported for the specified key to the
        ///     specified window.  The returned state is one of `GLFW_PRESS` or
        ///     `GLFW_RELEASE`.  The higher-level action `GLFW_REPEAT` is only reported to
        ///     the key callback.
        ///     If the `GLFW_STICKY_KEYS` input mode is enabled, this function returns
        ///     `GLFW_PRESS` the first time you call it for a key that was pressed, even if
        ///     that key has already been released.
        ///     The key functions deal with physical keys, with [key tokens](
        ///     named after their use on the standard US keyboard layout.  If you want to
        ///     input text, use the Unicode character callback instead.
        ///     The [modifier key bit masks](
        ///     used with this function.
        ///     __Do not use this function__ to implement [text input](
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="key">
        ///     The desired [keyboard key](
        ///     not a valid key for this function.
        /// </param>
        /// <returns>
        ///     One of `GLFW_PRESS` or `GLFW_RELEASE`.
        ///     Possible errors include
        ///     GLFW_INVALID_ENUM.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static int GetKey(GlfWwindow window, int key)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var ret = Public.GetKey_0(arg0, key);
            return ret;
        }

        /// <summary>
        ///     This function returns the last state reported for the specified mouse button
        ///     to the specified window.  The returned state is one of `GLFW_PRESS` or
        ///     `GLFW_RELEASE`.
        ///     If the `GLFW_STICKY_MOUSE_BUTTONS` input mode is enabled, this function
        ///     `GLFW_PRESS` the first time you call it for a mouse button that was pressed,
        ///     even if that mouse button has already been released.
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="button">The desired [mouse button](</param>
        /// <returns>
        ///     One of `GLFW_PRESS` or `GLFW_RELEASE`.
        ///     Possible errors include
        ///     GLFW_INVALID_ENUM.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static int GetMouseButton(GlfWwindow window, int button)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var ret = Public.GetMouseButton_0(arg0, button);
            return ret;
        }

        /// <summary>
        ///     This function returns the position of the cursor, in screen coordinates,
        ///     relative to the upper-left corner of the client area of the specified
        ///     window.
        ///     If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor
        ///     position is unbounded and limited only by the minimum and maximum values of
        ///     a `double`.
        ///     The coordinate can be converted to their integer equivalents with the
        ///     `floor` function.  Casting directly to an integer type works for positive
        ///     coordinates, but fails for negative ones.
        ///     Any or all of the position arguments may be `NULL`.  If an error occurs, all
        ///     non-`NULL` position arguments will be set to zero.
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="xpos">
        ///     Where to store the cursor x-coordinate, relative to the
        ///     left edge of the client area, or `NULL`.
        /// </param>
        /// <param name="ypos">
        ///     Where to store the cursor y-coordinate, relative to the to
        ///     top edge of the client area, or `NULL`.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void GetCursorPos(GlfWwindow window, ref double xpos, ref double ypos)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            fixed (double* refParamPtr1 = &xpos)
            {
                var arg1 = refParamPtr1;
                fixed (double* refParamPtr2 = &ypos)
                {
                    var arg2 = refParamPtr2;
                    Public.GetCursorPos_0(arg0, arg1, arg2);
                }
            }
        }

        /// <summary>
        ///     This function sets the position, in screen coordinates, of the cursor
        ///     relative to the upper-left corner of the client area of the specified
        ///     window.  The window must have input focus.  If the window does not have
        ///     input focus when this function is called, it fails silently.
        ///     __Do not use this function__ to implement things like camera controls.  GLFW
        ///     already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the
        ///     cursor, transparently re-centers it and provides unconstrained cursor
        ///     motion.  See
        ///     If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is
        ///     unconstrained and limited only by the minimum and maximum values of
        ///     a `double`.
        /// </summary>
        /// <param name="window">The desired window.</param>
        /// <param name="xpos">
        ///     The desired x-coordinate, relative to the left edge of the
        ///     client area.
        /// </param>
        /// <param name="ypos">
        ///     The desired y-coordinate, relative to the top edge of the
        ///     client area.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetCursorPos(GlfWwindow window, double xpos, double ypos)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.SetCursorPos_0(arg0, xpos, ypos);
        }

        /// <summary>
        ///     Creates a new custom cursor image that can be set for a window with
        ///     glfwSetCursor.  The cursor can be destroyed with
        ///     Any remaining cursors are destroyed by
        ///     The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight
        ///     bits per channel.  They are arranged canonically as packed sequential rows,
        ///     starting from the top-left corner.
        ///     The cursor hotspot is specified in pixels, relative to the upper-left corner
        ///     of the cursor image.  Like all other coordinate systems in GLFW, the X-axis
        ///     points to the right and the Y-axis points down.
        /// </summary>
        /// <param name="image">The desired cursor image.</param>
        /// <param name="xhot">The desired x-coordinate, in pixels, of the cursor hotspot.</param>
        /// <param name="yhot">The desired y-coordinate, in pixels, of the cursor hotspot.</param>
        /// <returns>
        ///     The handle of the created cursor, or `NULL` if an
        ///     [error](
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _lifetime The specified image data is copied before this function
        ///     returns.
        ///     This function must not be called from a callback.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWcursor CreateCursor(GlfWimage image, int xhot, int yhot)
        {
            var arg0 = image?.Instance ?? IntPtr.Zero;
            var ret = Public.CreateCursor_0(arg0, xhot, yhot);
            GlfWcursor result0;
            if (ret == IntPtr.Zero) result0 = null;
            else if (GlfWcursor.NativeToManagedMap.ContainsKey(ret))
                result0 = GlfWcursor.NativeToManagedMap[ret];
            else result0 = GlfWcursor.__CreateInstance(ret);
            return result0;
        }

        /// <summary>
        ///     Returns a cursor with a [standard shape](
        ///     a window with
        /// </summary>
        /// <param name="shape">One of the [standard shapes](</param>
        /// <returns>
        ///     A new cursor ready to use or `NULL` if an
        ///     [error](
        ///     Possible errors include
        ///     GLFW_INVALID_ENUM and
        ///     This function must not be called from a callback.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWcursor CreateStandardCursor(int shape)
        {
            var ret = Public.CreateStandardCursor_0(shape);
            GlfWcursor result0;
            if (ret == IntPtr.Zero) result0 = null;
            else if (GlfWcursor.NativeToManagedMap.ContainsKey(ret))
                result0 = GlfWcursor.NativeToManagedMap[ret];
            else result0 = GlfWcursor.__CreateInstance(ret);
            return result0;
        }

        /// <summary>
        ///     This function destroys a cursor previously created with
        ///     glfwCreateCursor.  Any remaining cursors will be destroyed by
        ///     glfwTerminate.
        /// </summary>
        /// <param name="cursor">
        ///     The cursor object to destroy.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     This function must not be called from a callback.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void DestroyCursor(GlfWcursor cursor)
        {
            var arg0 = cursor?.Instance ?? IntPtr.Zero;
            Public.DestroyCursor_0(arg0);
        }

        /// <summary>
        ///     This function sets the cursor image to be used when the cursor is over the
        ///     client area of the specified window.  The set cursor will only be visible
        ///     when the [cursor mode](
        ///     `GLFW_CURSOR_NORMAL`.
        ///     On some platforms, the set cursor may not be visible unless the window also
        ///     has input focus.
        /// </summary>
        /// <param name="window">The window to set the cursor for.</param>
        /// <param name="cursor">
        ///     The cursor to set, or `NULL` to switch back to the default
        ///     arrow cursor.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetCursor(GlfWwindow window, GlfWcursor cursor)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cursor?.Instance ?? IntPtr.Zero;
            Public.SetCursor_0(arg0, arg1);
        }

        /// <summary>
        ///     This function sets the key callback of the specified window, which is called
        ///     when a key is pressed, repeated or released.
        ///     The key functions deal with physical keys, with layout independent
        ///     [key tokens](
        ///     layout.  If you want to input text, use the
        ///     [character callback](
        ///     When a window loses input focus, it will generate synthetic key release
        ///     events for all pressed keys.  You can tell these events from user-generated
        ///     events by the fact that the synthetic ones are generated after the focus
        ///     loss event has been processed, i.e. after the
        ///     [window focus callback](
        ///     The scancode of a key is specific to that platform or sometimes even to that
        ///     machine.  Scancodes are intended to allow users to bind keys that don't have
        ///     a GLFW key token.  Such keys have `key` set to `GLFW_KEY_UNKNOWN`, their
        ///     state is not saved and so it cannot be queried with
        ///     Sometimes GLFW needs to generate synthetic key events, in which case the
        ///     scancode may be zero.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new key callback, or `NULL` to remove the currently
        ///     set callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWkeyfun SetKeyCallback(GlfWwindow window, GlfWkeyfun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetKeyCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWkeyfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWkeyfun));
        }

        /// <summary>
        ///     This function sets the character callback of the specified window, which is
        ///     called when a Unicode character is input.
        ///     The character callback is intended for Unicode text input.  As it deals with
        ///     characters, it is keyboard layout dependent, whereas the
        ///     [key callback](
        ///     to physical keys, as a key may produce zero, one or more characters.  If you
        ///     want to know whether a specific physical key was pressed or released, see
        ///     the key callback instead.
        ///     The character callback behaves as system text input normally does and will
        ///     not be called if modifier keys are held down that would prevent normal text
        ///     input on that platform, for example a Super (Command) key on OS X or Alt key
        ///     on Windows.  There is a
        ///     [character with modifiers callback](
        ///     receives these events.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWcharfun SetCharCallback(GlfWwindow window, GlfWcharfun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetCharCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWcharfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWcharfun));
        }

        /// <summary>
        ///     This function sets the character with modifiers callback of the specified
        ///     window, which is called when a Unicode character is input regardless of what
        ///     modifier keys are used.
        ///     The character with modifiers callback is intended for implementing custom
        ///     Unicode character input.  For regular Unicode text input, see the
        ///     [character callback](
        ///     callback, the character with modifiers callback deals with characters and is
        ///     keyboard layout dependent.  Characters do not map 1:1 to physical keys, as
        ///     a key may produce zero, one or more characters.  If you want to know whether
        ///     a specific physical key was pressed or released, see the
        ///     [key callback](
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or an
        ///     [error](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWcharmodsfun SetCharModsCallback(GlfWwindow window, GlfWcharmodsfun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetCharModsCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWcharmodsfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWcharmodsfun));
        }

        /// <summary>
        ///     This function sets the mouse button callback of the specified window, which
        ///     is called when a mouse button is pressed or released.
        ///     When a window loses input focus, it will generate synthetic mouse button
        ///     release events for all pressed mouse buttons.  You can tell these events
        ///     from user-generated events by the fact that the synthetic ones are generated
        ///     after the focus loss event has been processed, i.e. after the
        ///     [window focus callback](
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWmousebuttonfun SetMouseButtonCallback(GlfWwindow window, GlfWmousebuttonfun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetMouseButtonCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWmousebuttonfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWmousebuttonfun));
        }

        /// <summary>
        ///     This function sets the cursor position callback of the specified window,
        ///     which is called when the cursor is moved.  The callback is provided with the
        ///     position, in screen coordinates, relative to the upper-left corner of the
        ///     client area of the window.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWcursorposfun SetCursorPosCallback(GlfWwindow window, GlfWcursorposfun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetCursorPosCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWcursorposfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWcursorposfun));
        }

        /// <summary>
        ///     This function sets the cursor boundary crossing callback of the specified
        ///     window, which is called when the cursor enters or leaves the client area of
        ///     the window.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWcursorenterfun SetCursorEnterCallback(GlfWwindow window, GlfWcursorenterfun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetCursorEnterCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWcursorenterfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWcursorenterfun));
        }

        /// <summary>
        ///     This function sets the scroll callback of the specified window, which is
        ///     called when a scrolling device is used, such as a mouse wheel or scrolling
        ///     area of a touchpad.
        ///     The scroll callback receives all scrolling input, like that from a mouse
        ///     wheel or a touchpad scrolling area.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new scroll callback, or `NULL` to remove the currently
        ///     set callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWscrollfun SetScrollCallback(GlfWwindow window, GlfWscrollfun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetScrollCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWscrollfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWscrollfun));
        }

        /// <summary>
        ///     This function sets the file drop callback of the specified window, which is
        ///     called when one or more dragged files are dropped on the window.
        ///     Because the path array and its strings may have been generated specifically
        ///     for that event, they are not guaranteed to be valid after the callback has
        ///     returned.  If you wish to use them after the callback returns, you need to
        ///     make a deep copy.
        /// </summary>
        /// <param name="window">The window whose callback to set.</param>
        /// <param name="cbfun">
        ///     The new file drop callback, or `NULL` to remove the
        ///     currently set callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWdropfun SetDropCallback(GlfWwindow window, GlfWdropfun cbfun)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var arg1 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetDropCallback_0(arg0, arg1);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWdropfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWdropfun));
        }

        /// <summary>  This function returns whether the specified joystick is present.</summary>
        /// <param name="joy">The [joystick](</param>
        /// <returns>
        ///     `GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise.
        ///     Possible errors include
        ///     GLFW_INVALID_ENUM and
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static int JoystickPresent(int joy)
        {
            var ret = Public.JoystickPresent_0(joy);
            return ret;
        }

        /// <summary>
        ///     This function returns the values of all axes of the specified joystick.
        ///     Each element in the array is a value between -1.0 and 1.0.
        ///     Querying a joystick slot with no device present is not an error, but will
        ///     cause this function to return `NULL`.  Call
        ///     check device presence.
        /// </summary>
        /// <param name="joy">The [joystick](</param>
        /// <param name="count">
        ///     Where to store the number of axis values in the returned
        ///     array.  This is set to zero if the joystick is not present or an error
        ///     occurred.
        /// </param>
        /// <returns>
        ///     An array of axis values, or `NULL` if the joystick is not present or
        ///     an [error](
        ///     Possible errors include
        ///     GLFW_INVALID_ENUM and
        ///     _lifetime The returned array is allocated and freed by GLFW.  You
        ///     should not free it yourself.  It is valid until the specified joystick is
        ///     disconnected, this function is called again for that joystick or the library
        ///     is terminated.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static float* GetJoystickAxes(int joy, ref int count)
        {
            fixed (int* refParamPtr1 = &count)
            {
                var arg1 = refParamPtr1;
                var ret = Public.GetJoystickAxes_0(joy, arg1);
                return ret;
            }
        }

        /// <summary>
        ///     This function returns the state of all buttons of the specified joystick.
        ///     Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.
        ///     Querying a joystick slot with no device present is not an error, but will
        ///     cause this function to return `NULL`.  Call
        ///     check device presence.
        /// </summary>
        /// <param name="joy">The [joystick](</param>
        /// <param name="count">
        ///     Where to store the number of button states in the returned
        ///     array.  This is set to zero if the joystick is not present or an error
        ///     occurred.
        /// </param>
        /// <returns>
        ///     An array of button states, or `NULL` if the joystick is not present
        ///     or an [error](
        ///     Possible errors include
        ///     GLFW_INVALID_ENUM and
        ///     _lifetime The returned array is allocated and freed by GLFW.  You
        ///     should not free it yourself.  It is valid until the specified joystick is
        ///     disconnected, this function is called again for that joystick or the library
        ///     is terminated.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static byte* GetJoystickButtons(int joy, ref int count)
        {
            fixed (int* refParamPtr1 = &count)
            {
                var arg1 = refParamPtr1;
                var ret = Public.GetJoystickButtons_0(joy, arg1);
                return ret;
            }
        }

        /// <summary>
        ///     This function returns the name, encoded as UTF-8, of the specified joystick.
        ///     The returned string is allocated and freed by GLFW.  You should not free it
        ///     yourself.
        ///     Querying a joystick slot with no device present is not an error, but will
        ///     cause this function to return `NULL`.  Call
        ///     check device presence.
        /// </summary>
        /// <param name="joy">The [joystick](</param>
        /// <returns>
        ///     The UTF-8 encoded name of the joystick, or `NULL` if the joystick
        ///     is not present or an [error](
        ///     Possible errors include
        ///     GLFW_INVALID_ENUM and
        ///     _lifetime The returned string is allocated and freed by GLFW.  You
        ///     should not free it yourself.  It is valid until the specified joystick is
        ///     disconnected, this function is called again for that joystick or the library
        ///     is terminated.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static string GetJoystickName(int joy)
        {
            var ret = Public.GetJoystickName_0(joy);
            return Marshal.PtrToStringAnsi(ret);
        }

        /// <summary>
        ///     This function sets the joystick configuration callback, or removes the
        ///     currently set callback.  This is called when a joystick is connected to or
        ///     disconnected from the system.
        /// </summary>
        /// <param name="cbfun">
        ///     The new callback, or `NULL` to remove the currently set
        ///     callback.
        /// </param>
        /// <returns>
        ///     The previously set callback, or `NULL` if no callback was set or the
        ///     library had not been [initialized](
        ///     Possible errors include
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static GlfWjoystickfun SetJoystickCallback(GlfWjoystickfun cbfun)
        {
            var arg0 = cbfun == null ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cbfun);
            var ret = Public.SetJoystickCallback_0(arg0);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWjoystickfun)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWjoystickfun));
        }

        /// <summary>
        ///     This function sets the system clipboard to the specified, UTF-8 encoded
        ///     string.
        /// </summary>
        /// <param name="window">The window that will own the clipboard contents.</param>
        /// <param name="string">
        ///     A UTF-8 encoded string.
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _lifetime The specified string is copied before this function
        ///     returns.
        ///     _safety This function must only be called from the main thread.
        /// </param>
        public static void SetClipboardString(GlfWwindow window, string @string)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.SetClipboardString_0(arg0, @string);
        }

        /// <summary>
        ///     This function returns the contents of the system clipboard, if it contains
        ///     or is convertible to a UTF-8 encoded string.  If the clipboard is empty or
        ///     if its contents cannot be converted, `NULL` is returned and a
        ///     GLFW_FORMAT_UNAVAILABLE error is generated.
        /// </summary>
        /// <param name="window">The window that will request the clipboard contents.</param>
        /// <returns>
        ///     The contents of the clipboard as a UTF-8 encoded string, or `NULL`
        ///     if an [error](
        ///     Possible errors include
        ///     GLFW_PLATFORM_ERROR.
        ///     _lifetime The returned string is allocated and freed by GLFW.  You
        ///     should not free it yourself.  It is valid until the next call to
        ///     glfwGetClipboardString or
        ///     is terminated.
        ///     _safety This function must only be called from the main thread.
        /// </returns>
        public static string GetClipboardString(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            var ret = Public.GetClipboardString_0(arg0);
            return Marshal.PtrToStringAnsi(ret);
        }

        /// <summary>
        ///     This function returns the value of the GLFW timer.  Unless the timer has
        ///     been set using
        ///     was initialized.
        ///     The resolution of the timer is system dependent, but is usually on the order
        ///     of a few micro- or nanoseconds.  It uses the highest-resolution monotonic
        ///     time source on each supported platform.
        /// </summary>
        /// <returns>
        ///     The current value, in seconds, or zero if an
        ///     [error](
        ///     Possible errors include
        ///     _safety This function may be called from any thread.  Reading and
        ///     writing of the public timer offset is not atomic, so it needs to be
        ///     externally synchronized with calls to
        /// </returns>
        public static double GetTime()
        {
            var ret = Public.GetTime_0();
            return ret;
        }

        /// <summary>
        ///     This function sets the value of the GLFW timer.  It then continues to count
        ///     up from that value.  The value must be a positive finite number less than
        ///     or equal to 18446744073.0, which is approximately 584.5 years.
        /// </summary>
        /// <param name="time">
        ///     The new value, in seconds.
        ///     Possible errors include
        ///     GLFW_INVALID_VALUE.
        ///     _safety This function may be called from any thread.  Reading and
        ///     writing of the public timer offset is not atomic, so it needs to be
        ///     externally synchronized with calls to
        /// </param>
        public static void SetTime(double time)
        {
            Public.SetTime_0(time);
        }

        /// <summary>
        ///     This function returns the current value of the raw timer, measured in
        ///     1
        ///     &#160;
        ///     /
        ///     &#160;
        ///     frequency seconds.  To get the frequency, call
        ///     glfwGetTimerFrequency.
        /// </summary>
        /// <returns>
        ///     The value of the timer, or zero if an
        ///     [error](
        ///     Possible errors include
        ///     _safety This function may be called from any thread.
        /// </returns>
        public static ulong GetTimerValue()
        {
            var ret = Public.GetTimerValue_0();
            return ret;
        }

        /// <summary>  This function returns the frequency, in Hz, of the raw timer.</summary>
        /// <returns>
        ///     The frequency of the timer, in Hz, or zero if an
        ///     [error](
        ///     Possible errors include
        ///     _safety This function may be called from any thread.
        /// </returns>
        public static ulong GetTimerFrequency()
        {
            var ret = Public.GetTimerFrequency_0();
            return ret;
        }

        /// <summary>
        ///     This function makes the OpenGL or OpenGL ES context of the specified window
        ///     current on the calling thread.  A context can only be made current on
        ///     a single thread at a time and each thread can have only a single current
        ///     context at a time.
        ///     By default, making a context non-current implicitly forces a pipeline flush.
        ///     On machines that support `GL_KHR_context_flush_control`, you can control
        ///     whether a context performs this flush by setting the
        ///     [GLFW_CONTEXT_RELEASE_BEHAVIOR](
        ///     The specified window must have an OpenGL or OpenGL ES context.  Specifying
        ///     a window without a context will generate a
        ///     error.
        /// </summary>
        /// <param name="window">
        ///     The window whose context to make current, or `NULL` to
        ///     detach the current context.
        ///     Possible errors include
        ///     GLFW_NO_WINDOW_CONTEXT and
        ///     _safety This function may be called from any thread.
        /// </param>
        public static void MakeContextCurrent(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.MakeContextCurrent_0(arg0);
        }

        /// <summary>
        ///     This function returns the window whose OpenGL or OpenGL ES context is
        ///     current on the calling thread.
        /// </summary>
        /// <returns>
        ///     The window whose context is current, or `NULL` if no window's
        ///     context is current.
        ///     Possible errors include
        ///     _safety This function may be called from any thread.
        /// </returns>
        public static GlfWwindow GetCurrentContext()
        {
            var ret = Public.GetCurrentContext_0();
            GlfWwindow result0;
            if (ret == IntPtr.Zero) result0 = null;
            else result0 = GlfWwindow.__CreateInstance(ret);
            return result0;
        }

        /// <summary>
        ///     This function swaps the front and back buffers of the specified window when
        ///     rendering with OpenGL or OpenGL ES.  If the swap interval is greater than
        ///     zero, the GPU driver waits the specified number of screen updates before
        ///     swapping the buffers.
        ///     The specified window must have an OpenGL or OpenGL ES context.  Specifying
        ///     a window without a context will generate a
        ///     error.
        ///     This function does not apply to Vulkan.  If you are rendering with Vulkan,
        ///     see `vkQueuePresentKHR` instead.
        /// </summary>
        /// <param name="window">
        ///     The window whose buffers to swap.
        ///     Possible errors include
        ///     GLFW_NO_WINDOW_CONTEXT and
        ///     _safety This function may be called from any thread.
        /// </param>
        public static void SwapBuffers(GlfWwindow window)
        {
            var arg0 = window?.Instance ?? IntPtr.Zero;
            Public.SwapBuffers_0(arg0);
        }

        /// <summary>
        ///     This function sets the swap interval for the current OpenGL or OpenGL ES
        ///     context, i.e. the number of screen updates to wait from the time
        ///     glfwSwapBuffers was called before swapping the buffers and returning.  This
        ///     is sometimes called _vertical synchronization_, _vertical retrace
        ///     synchronization_ or just _vsync_.
        ///     Contexts that support either of the `WGL_EXT_swap_control_tear` and
        ///     `GLX_EXT_swap_control_tear` extensions also accept negative swap intervals,
        ///     which allow the driver to swap even if a frame arrives a little bit late.
        ///     You can check for the presence of these extensions using
        ///     glfwExtensionSupported.  For more information about swap tearing, see the
        ///     extension specifications.
        ///     A context must be current on the calling thread.  Calling this function
        ///     without a current context will cause a
        ///     This function does not apply to Vulkan.  If you are rendering with Vulkan,
        ///     see the present mode of your swapchain instead.
        /// </summary>
        /// <param name="interval">
        ///     The minimum number of screen updates to wait for
        ///     until the buffers are swapped by
        ///     Possible errors include
        ///     GLFW_NO_CURRENT_CONTEXT and
        ///     _safety This function may be called from any thread.
        /// </param>
        public static void SwapInterval(int interval)
        {
            Public.SwapInterval_0(interval);
        }

        /// <summary>
        ///     This function returns whether the specified
        ///     [API extension](
        ///     OpenGL ES context.  It searches both for client API extension and context
        ///     creation API extensions.
        ///     A context must be current on the calling thread.  Calling this function
        ///     without a current context will cause a
        ///     As this functions retrieves and searches one or more extension strings each
        ///     call, it is recommended that you cache its results if it is going to be used
        ///     frequently.  The extension strings will not change during the lifetime of
        ///     a context, so there is no danger in doing this.
        ///     This function does not apply to Vulkan.  If you are using Vulkan, see
        ///     glfwGetRequiredInstanceExtensions, `vkEnumerateInstanceExtensionProperties`
        ///     and `vkEnumerateDeviceExtensionProperties` instead.
        /// </summary>
        /// <param name="extension">The ASCII encoded name of the extension.</param>
        /// <returns>
        ///     `GLFW_TRUE` if the extension is available, or `GLFW_FALSE`
        ///     otherwise.
        ///     Possible errors include
        ///     GLFW_NO_CURRENT_CONTEXT,
        ///     GLFW_PLATFORM_ERROR.
        ///     _safety This function may be called from any thread.
        /// </returns>
        public static int ExtensionSupported(string extension)
        {
            var ret = Public.ExtensionSupported_0(extension);
            return ret;
        }

        /// <summary>
        ///     This function returns the address of the specified OpenGL or OpenGL ES
        ///     [core or extension function](
        ///     by the current context.
        ///     A context must be current on the calling thread.  Calling this function
        ///     without a current context will cause a
        ///     This function does not apply to Vulkan.  If you are rendering with Vulkan,
        ///     see
        ///     `vkGetDeviceProcAddr` instead.
        /// </summary>
        /// <param name="procname">The ASCII encoded name of the function.</param>
        /// <returns>
        ///     The address of the function, or `NULL` if an
        ///     [error](
        ///     Possible errors include
        ///     GLFW_NO_CURRENT_CONTEXT and
        ///     _lifetime The returned function pointer is valid until the context
        ///     is destroyed or the library is terminated.
        ///     _safety This function may be called from any thread.
        /// </returns>
        public static GlfWglproc GetProcAddress(string procname)
        {
            var ret = Public.GetProcAddress_0(procname);
            var ptr0 = ret;
            return ptr0 == IntPtr.Zero ? null : (GlfWglproc)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(GlfWglproc));
        }

        /// <summary>
        ///     This function returns whether the Vulkan loader has been found.  This check
        ///     is performed by
        ///     The availability of a Vulkan loader does not by itself guarantee that window
        ///     surface creation or even device creation is possible.  Call
        ///     glfwGetRequiredInstanceExtensions to check whether the extensions necessary
        ///     for Vulkan surface creation are available and
        ///     glfwGetPhysicalDevicePresentationSupport to check whether a queue family of
        ///     a physical device supports image presentation.
        /// </summary>
        /// <returns>
        ///     `GLFW_TRUE` if Vulkan is available, or `GLFW_FALSE` otherwise.
        ///     Possible errors include
        ///     _safety This function may be called from any thread.
        /// </returns>
        public static int VulkanSupported()
        {
            var ret = Public.VulkanSupported_0();
            return ret;
        }

        /// <summary>
        ///     This function returns an array of names of Vulkan instance extensions required
        ///     by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the
        ///     list will always contains `VK_KHR_surface`, so if you don't require any
        ///     additional extensions you can pass this list directly to the
        ///     `VkInstanceCreateInfo` struct.
        ///     If Vulkan is not available on the machine, this function returns `NULL` and
        ///     generates a
        ///     to check whether Vulkan is available.
        ///     If Vulkan is available but no set of extensions allowing window surface
        ///     creation was found, this function returns `NULL`.  You may still use Vulkan
        ///     for off-screen rendering and compute work.
        /// </summary>
        /// <param name="count">
        ///     Where to store the number of extensions in the returned
        ///     array.  This is set to zero if an error occurred.
        /// </param>
        /// <returns>
        ///     An array of ASCII encoded extension names, or `NULL` if an
        ///     [error](
        ///     Possible errors include
        ///     GLFW_API_UNAVAILABLE.
        ///     _lifetime The returned array is allocated and freed by GLFW.  You
        ///     should not free it yourself.  It is guaranteed to be valid only until the
        ///     library is terminated.
        ///     _safety This function may be called from any thread.
        /// </returns>
        public static sbyte** GetRequiredInstanceExtensions(ref uint count)
        {
            fixed (uint* refParamPtr0 = &count)
            {
                var arg0 = refParamPtr0;
                var ret = Public.GetRequiredInstanceExtensions_0(arg0);
                return ret;
            }
        }

        public struct Public
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwInit")]
            public static extern int Init_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwTerminate")]
            public static extern void Terminate_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "getTests")]
            public static extern IntPtr GetTests_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetVersion")]
            public static extern void GetVersion_0(int* major, int* minor, int* rev);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetVersionString")]
            public static extern IntPtr GetVersionString_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetErrorCallback")]
            public static extern IntPtr SetErrorCallback_0(IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetMonitors")]
            public static extern IntPtr GetMonitors_0(int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetPrimaryMonitor")]
            public static extern IntPtr GetPrimaryMonitor_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetMonitorPos")]
            public static extern void GetMonitorPos_0(IntPtr monitor, int* xpos, int* ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetMonitorPhysicalSize")]
            public static extern void GetMonitorPhysicalSize_0(IntPtr monitor, int* widthMm, int* heightMm);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetMonitorName")]
            public static extern IntPtr GetMonitorName_0(IntPtr monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetMonitorCallback")]
            public static extern IntPtr SetMonitorCallback_0(IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetVideoModes")]
            public static extern IntPtr GetVideoModes_0(IntPtr monitor, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetVideoMode")]
            public static extern IntPtr GetVideoMode_0(IntPtr monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetGamma")]
            public static extern void SetGamma_0(IntPtr monitor, float gamma);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetGammaRamp")]
            public static extern IntPtr GetGammaRamp_0(IntPtr monitor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetGammaRamp")]
            public static extern void SetGammaRamp_0(IntPtr monitor, IntPtr ramp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwDefaultWindowHints")]
            public static extern void DefaultWindowHints_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwWindowHint")]
            public static extern void WindowHint_0(int hint, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwCreateWindow")]
            public static extern IntPtr CreateWindow_0(int width, int height, [MarshalAs(UnmanagedType.LPStr)] string title, IntPtr monitor, IntPtr share);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwDestroyWindow")]
            public static extern void DestroyWindow_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwWindowShouldClose")]
            public static extern int WindowShouldClose_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowShouldClose")]
            public static extern void SetWindowShouldClose_0(IntPtr window, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowTitle")]
            public static extern void SetWindowTitle_0(IntPtr window, [MarshalAs(UnmanagedType.LPStr)] string title);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowIcon")]
            public static extern void SetWindowIcon_0(IntPtr window, int count, IntPtr images);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetWindowPos")]
            public static extern void GetWindowPos_0(IntPtr window, int* xpos, int* ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowPos")]
            public static extern void SetWindowPos_0(IntPtr window, int xpos, int ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetWindowSize")]
            public static extern void GetWindowSize_0(IntPtr window, int* width, int* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowSizeLimits")]
            public static extern void SetWindowSizeLimits_0(IntPtr window, int minwidth, int minheight, int maxwidth, int maxheight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowAspectRatio")]
            public static extern void SetWindowAspectRatio_0(IntPtr window, int numer, int denom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowSize")]
            public static extern void SetWindowSize_0(IntPtr window, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetFramebufferSize")]
            public static extern void GetFramebufferSize_0(IntPtr window, int* width, int* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetWindowFrameSize")]
            public static extern void GetWindowFrameSize_0(IntPtr window, int* left, int* top, int* right, int* bottom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwIconifyWindow")]
            public static extern void IconifyWindow_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwRestoreWindow")]
            public static extern void RestoreWindow_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwMaximizeWindow")]
            public static extern void MaximizeWindow_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwShowWindow")]
            public static extern void ShowWindow_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwHideWindow")]
            public static extern void HideWindow_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwFocusWindow")]
            public static extern void FocusWindow_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetWindowMonitor")]
            public static extern IntPtr GetWindowMonitor_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowMonitor")]
            public static extern void SetWindowMonitor_0(IntPtr window, IntPtr monitor, int xpos, int ypos, int width, int height, int refreshRate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetWindowAttrib")]
            public static extern int GetWindowAttrib_0(IntPtr window, int attrib);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowUserPointer")]
            public static extern void SetWindowUserPointer_0(IntPtr window, IntPtr pointer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetWindowUserPointer")]
            public static extern IntPtr GetWindowUserPointer_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowPosCallback")]
            public static extern IntPtr SetWindowPosCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowSizeCallback")]
            public static extern IntPtr SetWindowSizeCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowCloseCallback")]
            public static extern IntPtr SetWindowCloseCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowRefreshCallback")]
            public static extern IntPtr SetWindowRefreshCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowFocusCallback")]
            public static extern IntPtr SetWindowFocusCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetWindowIconifyCallback")]
            public static extern IntPtr SetWindowIconifyCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetFramebufferSizeCallback")]
            public static extern IntPtr SetFramebufferSizeCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwPollEvents")]
            public static extern void PollEvents_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwWaitEvents")]
            public static extern void WaitEvents_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwWaitEventsTimeout")]
            public static extern void WaitEventsTimeout_0(double timeout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwPostEmptyEvent")]
            public static extern void PostEmptyEvent_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetInputMode")]
            public static extern int GetInputMode_0(IntPtr window, int mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetInputMode")]
            public static extern void SetInputMode_0(IntPtr window, int mode, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetKeyName")]
            public static extern IntPtr GetKeyName_0(int key, int scancode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetKey")]
            public static extern int GetKey_0(IntPtr window, int key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetMouseButton")]
            public static extern int GetMouseButton_0(IntPtr window, int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetCursorPos")]
            public static extern void GetCursorPos_0(IntPtr window, double* xpos, double* ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetCursorPos")]
            public static extern void SetCursorPos_0(IntPtr window, double xpos, double ypos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwCreateCursor")]
            public static extern IntPtr CreateCursor_0(IntPtr image, int xhot, int yhot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwCreateStandardCursor")]
            public static extern IntPtr CreateStandardCursor_0(int shape);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwDestroyCursor")]
            public static extern void DestroyCursor_0(IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetCursor")]
            public static extern void SetCursor_0(IntPtr window, IntPtr cursor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetKeyCallback")]
            public static extern IntPtr SetKeyCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetCharCallback")]
            public static extern IntPtr SetCharCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetCharModsCallback")]
            public static extern IntPtr SetCharModsCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetMouseButtonCallback")]
            public static extern IntPtr SetMouseButtonCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetCursorPosCallback")]
            public static extern IntPtr SetCursorPosCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetCursorEnterCallback")]
            public static extern IntPtr SetCursorEnterCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetScrollCallback")]
            public static extern IntPtr SetScrollCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetDropCallback")]
            public static extern IntPtr SetDropCallback_0(IntPtr window, IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwJoystickPresent")]
            public static extern int JoystickPresent_0(int joy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetJoystickAxes")]
            public static extern float* GetJoystickAxes_0(int joy, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetJoystickButtons")]
            public static extern byte* GetJoystickButtons_0(int joy, int* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetJoystickName")]
            public static extern IntPtr GetJoystickName_0(int joy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetJoystickCallback")]
            public static extern IntPtr SetJoystickCallback_0(IntPtr cbfun);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetClipboardString")]
            public static extern void SetClipboardString_0(IntPtr window, [MarshalAs(UnmanagedType.LPStr)] string @string);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetClipboardString")]
            public static extern IntPtr GetClipboardString_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetTime")]
            public static extern double GetTime_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSetTime")]
            public static extern void SetTime_0(double time);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetTimerValue")]
            public static extern ulong GetTimerValue_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetTimerFrequency")]
            public static extern ulong GetTimerFrequency_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwMakeContextCurrent")]
            public static extern void MakeContextCurrent_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetCurrentContext")]
            public static extern IntPtr GetCurrentContext_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSwapBuffers")]
            public static extern void SwapBuffers_0(IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwSwapInterval")]
            public static extern void SwapInterval_0(int interval);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwExtensionSupported")]
            public static extern int ExtensionSupported_0([MarshalAs(UnmanagedType.LPStr)] string extension);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetProcAddress")]
            public static extern IntPtr GetProcAddress_0([MarshalAs(UnmanagedType.LPStr)] string procname);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwVulkanSupported")]
            public static extern int VulkanSupported_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("glfw3", CallingConvention = CallingConvention.Cdecl,
                EntryPoint = "glfwGetRequiredInstanceExtensions")]
            public static extern sbyte** GetRequiredInstanceExtensions_0(uint* count);
        }
    }
}
